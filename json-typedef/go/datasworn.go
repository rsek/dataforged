// Code generated by jtd-codegen for Go v0.2.1. DO NOT EDIT.

package Datasworn

import (
	"encoding/json"
	"fmt"
)

// Describes game rules compatible with the Ironsworn tabletop role-playing game
// by Shawn Tomkin.
type RulesPackage struct {
	PackageType string

	Expansion RulesPackageExpansion

	Ruleset RulesPackageRuleset
}

func (v RulesPackage) MarshalJSON() ([]byte, error) {
	switch v.PackageType {
	case "expansion":
		return json.Marshal(struct { T string `json:"package_type"`; RulesPackageExpansion }{ v.PackageType, v.Expansion })
	case "ruleset":
		return json.Marshal(struct { T string `json:"package_type"`; RulesPackageRuleset }{ v.PackageType, v.Ruleset })
	}

	return nil, fmt.Errorf("bad PackageType value: %s", v.PackageType)
}

func (v *RulesPackage) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"package_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "expansion":
		err = json.Unmarshal(b, &v.Expansion)
	case "ruleset":
		err = json.Unmarshal(b, &v.Ruleset)
	default:
		err = fmt.Errorf("bad PackageType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.PackageType = t.T
	return nil
}

// A Datasworn package that relies on an external package to provide its
// ruleset.
type RulesPackageExpansion struct {
	// The version of the Datasworn format used by this data.
	DataswornVersion SemanticVersion `json:"datasworn_version"`

	ID ExpansionID `json:"id"`

	Ruleset RulesetID `json:"ruleset"`

	// A dictionary object containing asset types, which contain assets.
	Assets map[string]AssetType `json:"assets,omitempty"`

	// A dictionary object containing atlas collections, which contain atlas
	// entries.
	Atlas map[string]Atlas `json:"atlas,omitempty"`

	// A dictionary object of delve sites, like the premade delve sites presented
	// in Ironsworn: Delve
	DelveSites map[string]DelveSite `json:"delve_sites,omitempty"`

	// A dictionary object containing move categories, which contain moves.
	Moves map[string]MoveCategory `json:"moves,omitempty"`

	// A dictionary object containing NPC collections, which contain NPCs.
	Npcs map[string]NpcCollection `json:"npcs,omitempty"`

	// A dictionary object containing oracle collections, which may contain oracle
	// tables and/or oracle collections.
	Oracles map[string]OracleCollection `json:"oracles,omitempty"`

	// A dictionary object containing rarities, like those presented in Ironsworn:
	// Delve.
	Rarities map[string]Rarity `json:"rarities,omitempty"`

	Rules *RulesExpansion `json:"rules,omitempty"`

	// A dictionary object containing delve site domains.
	SiteDomains map[string]DelveSiteDomain `json:"site_domains,omitempty"`

	// A dictionary object containing delve site themes.
	SiteThemes map[string]DelveSiteTheme `json:"site_themes,omitempty"`

	// A dictionary object of truth categories.
	Truths map[string]Truth `json:"truths,omitempty"`
}

// A standalone Datasworn package that describes its own ruleset.
type RulesPackageRuleset struct {
	// A dictionary object containing asset types, which contain assets.
	Assets map[string]AssetType `json:"assets"`

	// The version of the Datasworn format used by this data.
	DataswornVersion SemanticVersion `json:"datasworn_version"`

	ID RulesetID `json:"id"`

	// A dictionary object containing move categories, which contain moves.
	Moves map[string]MoveCategory `json:"moves"`

	// A dictionary object containing oracle collections, which may contain oracle
	// tables and/or oracle collections.
	Oracles map[string]OracleCollection `json:"oracles"`

	Rules Rules `json:"rules"`

	// A dictionary object containing atlas collections, which contain atlas
	// entries.
	Atlas map[string]Atlas `json:"atlas,omitempty"`

	// A dictionary object of delve sites, like the premade delve sites presented
	// in Ironsworn: Delve
	DelveSites map[string]DelveSite `json:"delve_sites,omitempty"`

	// A dictionary object containing NPC collections, which contain NPCs.
	Npcs map[string]NpcCollection `json:"npcs,omitempty"`

	// A dictionary object containing rarities, like those presented in Ironsworn:
	// Delve.
	Rarities map[string]Rarity `json:"rarities,omitempty"`

	// A dictionary object containing delve site domains.
	SiteDomains map[string]DelveSiteDomain `json:"site_domains,omitempty"`

	// A dictionary object containing delve site themes.
	SiteThemes map[string]DelveSiteTheme `json:"site_themes,omitempty"`

	// A dictionary object of truth categories.
	Truths map[string]Truth `json:"truths,omitempty"`
}

type ActionRollMethod string

const (
// Use **every** roll option at once.
	ActionRollMethodAll ActionRollMethod = "all"

// Use the roll option with the best/highest value.
	ActionRollMethodHighest ActionRollMethod = "highest"

// Use the roll option with the worst/lowest value.
	ActionRollMethodLowest ActionRollMethod = "lowest"

// An automatic miss.
	ActionRollMethodMiss ActionRollMethod = "miss"

// The player chooses which roll option to use.
	ActionRollMethodPlayerChoice ActionRollMethod = "player_choice"

// An automatic strong hit.
	ActionRollMethodStrongHit ActionRollMethod = "strong_hit"

// An automatic weak hit.
	ActionRollMethodWeakHit ActionRollMethod = "weak_hit"
)

type Asset struct {
	Abilities []AssetAbility `json:"abilities"`

	// A localized category label for this asset. This is the surtitle above the
	// asset's name on the card.
	AssetType Label `json:"asset_type"`

	// If `true`, this asset counts as an impact (Starforged) or a debility
	// (classic Ironsworn).
	CountAsImpact bool `json:"count_as_impact"`

	// The unique Datasworn ID for this item.
	ID AssetID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Most assets only benefit to their owner, but certain assets (like
	// Starforged's module and command vehicle assets) are shared amongst the
	// player's allies, too.
	Shared bool `json:"shared"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	Attachments *AssetAttachment `json:"attachments,omitempty"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this asset.
	Color *CSSColor `json:"color,omitempty"`

	// Controls are condition meters, clocks, counters, and other asset input
	// fields whose values are expected to change throughout the life of the asset.
	Controls map[string]AssetControlField `json:"controls,omitempty"`

	// This asset's icon.
	Icon *SvgImageURL `json:"icon,omitempty"`

	// Options are input fields set when the player purchases the asset. They're
	// likely to remain the same through the life of the asset. Typically, they are
	// rendered at the top of the asset card.
	Options map[string]AssetOptionField `json:"options,omitempty"`

	// Describes prerequisites for purchasing or using this asset.
	Requirement *MarkdownString `json:"requirement,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

// An asset ability: one of the purchasable features of an asset. Most assets
// have three.
type AssetAbility struct {
	// Is this asset ability enabled?
	Enabled bool `json:"enabled"`

	// The unique Datasworn ID for this item.
	ID AssetAbilityID `json:"id"`

	// The complete rules text of this asset ability.
	Text MarkdownString `json:"text"`

	// Fields whose values are expected to change over the life of the asset.
	Controls map[string]AssetAbilityControlField `json:"controls,omitempty"`

	// Changes made to the asset, when this ability is enabled.
	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	// Describes changes made to various moves by this asset ability. Usually these
	// require specific trigger conditions.
	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`

	// Unique moves added by this asset ability.
	Moves map[string]Move `json:"moves,omitempty"`

	// A handful of asset abilities have a label/name, for instance classic
	// Ironsworn companion assets. Most canonical assets omit this property.
	Name *Label `json:"name,omitempty"`

	// Fields that are expected to be set once and remain the same through the life
	// of the asset.
	Options map[string]AssetAbilityOptionField `json:"options,omitempty"`
}

type AssetAbilityControlField struct {
	FieldType string

	Checkbox AssetAbilityControlFieldCheckbox

	Clock AssetAbilityControlFieldClock

	Counter AssetAbilityControlFieldCounter
}

func (v AssetAbilityControlField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "checkbox":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldCheckbox }{ v.FieldType, v.Checkbox })
	case "clock":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldClock }{ v.FieldType, v.Clock })
	case "counter":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldCounter }{ v.FieldType, v.Counter })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetAbilityControlField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "checkbox":
		err = json.Unmarshal(b, &v.Checkbox)
	case "clock":
		err = json.Unmarshal(b, &v.Clock)
	case "counter":
		err = json.Unmarshal(b, &v.Counter)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

// Represents a checkbox.
type AssetAbilityControlFieldCheckbox struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// The unique Datasworn ID for this item.
	ID AssetAbilityControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	Label InputLabel `json:"label"`

	// Is the box checked?
	Value bool `json:"value"`
}

// A clock with 4, 6, 8, or 10 segments.
type AssetAbilityControlFieldClock struct {
	// The unique Datasworn ID for this item.
	ID AssetAbilityControlFieldID `json:"id"`

	Label InputLabel `json:"label"`

	// The size of the clock -- in other words, the maximum number of filled clock
	// segments.
	Max int8 `json:"max"`

	// The minimum number of filled clock segments. This is always 0.
	Min int8 `json:"min"`

	// The current number of filled clock segments.
	Value int8 `json:"value"`
}

// A counter that starts at zero, with an optional maximum value.
type AssetAbilityControlFieldCounter struct {
	// The unique Datasworn ID for this item.
	ID AssetAbilityControlFieldID `json:"id"`

	Label InputLabel `json:"label"`

	Max int16 `json:"max"`

	// The (inclusive) minimum value.
	Min int16 `json:"min"`

	// The current value of this input.
	Value int16 `json:"value"`
}

// A unique ID for an AssetAbilityControlField.
type AssetAbilityControlFieldID = string

// A unique ID for an AssetAbility.
type AssetAbilityID = string

type AssetAbilityOptionField struct {
	FieldType string

	Text AssetAbilityOptionFieldText
}

func (v AssetAbilityOptionField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "text":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityOptionFieldText }{ v.FieldType, v.Text })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetAbilityOptionField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "text":
		err = json.Unmarshal(b, &v.Text)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

// Represents an input that accepts plain text.
type AssetAbilityOptionFieldText struct {
	// The unique Datasworn ID for this item.
	ID AssetAbilityOptionFieldID `json:"id"`

	Label InputLabel `json:"label"`

	Value string `json:"value"`
}

// A unique ID for an AssetAbilityOptionField.
type AssetAbilityOptionFieldID = string

// Describes which assets can be attached to this asset. Example: Starforged's
// Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
// Starforged for more info.
type AssetAttachment struct {
	// Asset IDs (which may be wildcards) that may be attached to this asset
	Assets []AssetIDWildcard `json:"assets"`

	Max int16 `json:"max"`
}

// A checkbox control field, rendered as part of an asset condition meter.
type AssetConditionMeterControlField struct {
	FieldType string

	CardFlip AssetConditionMeterControlFieldCardFlip

	Checkbox AssetConditionMeterControlFieldCheckbox
}

func (v AssetConditionMeterControlField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "card_flip":
		return json.Marshal(struct { T string `json:"field_type"`; AssetConditionMeterControlFieldCardFlip }{ v.FieldType, v.CardFlip })
	case "checkbox":
		return json.Marshal(struct { T string `json:"field_type"`; AssetConditionMeterControlFieldCheckbox }{ v.FieldType, v.Checkbox })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetConditionMeterControlField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "card_flip":
		err = json.Unmarshal(b, &v.CardFlip)
	case "checkbox":
		err = json.Unmarshal(b, &v.Checkbox)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

// When its value is set to `true` it means that the card is flipped over.
// Some assets use this to represent a 'broken' state (e.g. Starforged Module
// assets).
type AssetConditionMeterControlFieldCardFlip struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// The unique Datasworn ID for this item.
	ID AssetConditionMeterControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	Label InputLabel `json:"label"`

	// Is the card flipped over?
	Value bool `json:"value"`
}

// Represents a checkbox.
type AssetConditionMeterControlFieldCheckbox struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// The unique Datasworn ID for this item.
	ID AssetConditionMeterControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	Label InputLabel `json:"label"`

	// Is the box checked?
	Value bool `json:"value"`
}

// A unique ID for an AssetConditionMeterControlField.
type AssetConditionMeterControlFieldID = string

type AssetControlField struct {
	FieldType string

	CardFlip AssetControlFieldCardFlip

	Checkbox AssetControlFieldCheckbox

	ConditionMeter AssetControlFieldConditionMeter

	SelectEnhancement AssetControlFieldSelectEnhancement
}

func (v AssetControlField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "card_flip":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldCardFlip }{ v.FieldType, v.CardFlip })
	case "checkbox":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldCheckbox }{ v.FieldType, v.Checkbox })
	case "condition_meter":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldConditionMeter }{ v.FieldType, v.ConditionMeter })
	case "select_enhancement":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldSelectEnhancement }{ v.FieldType, v.SelectEnhancement })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetControlField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "card_flip":
		err = json.Unmarshal(b, &v.CardFlip)
	case "checkbox":
		err = json.Unmarshal(b, &v.Checkbox)
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	case "select_enhancement":
		err = json.Unmarshal(b, &v.SelectEnhancement)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

// When its value is set to `true` it means that the card is flipped over.
// Some assets use this to represent a 'broken' state (e.g. Starforged Module
// assets).
type AssetControlFieldCardFlip struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// The unique Datasworn ID for this item.
	ID AssetControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	Label InputLabel `json:"label"`

	// Is the card flipped over?
	Value bool `json:"value"`
}

// Represents a checkbox.
type AssetControlFieldCheckbox struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// The unique Datasworn ID for this item.
	ID AssetControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	Label InputLabel `json:"label"`

	// Is the box checked?
	Value bool `json:"value"`
}

// Provides hints for moves that interact with this condition meter, such as
// suffer and recovery moves.
type AssetControlFieldConditionMeterMoves struct {
	// The ID(s) of recovery moves associated with this meter.
	Recover []MoveIDWildcard `json:"recover,omitempty"`

	// The ID(s) of suffer moves associated with the condition meter. If the
	// suffer move makes an action roll, this condition meter value should be made
	// available as a roll option.
	Suffer []MoveIDWildcard `json:"suffer,omitempty"`
}

// Some assets provide a special condition meter of their own. The most common
// example is the health meters on companion assets. Asset condition meters
// may also include their own controls, such as the checkboxes that Starforged
// companion assets use to indicate they are "out of action".
type AssetControlFieldConditionMeter struct {
	// The unique Datasworn ID for this item.
	ID AssetControlFieldID `json:"id"`

	Label InputLabel `json:"label"`

	// The maximum value of this meter.
	Max int8 `json:"max"`

	// The minimum value of this meter.
	Min int8 `json:"min"`

	// The current value of this meter.
	Value int8 `json:"value"`

	// Checkbox controls rendered as part of the condition meter.
	Controls map[string]AssetConditionMeterControlField `json:"controls,omitempty"`

	// Provides hints for moves that interact with this condition meter, such as
	// suffer and recovery moves.
	Moves *AssetControlFieldConditionMeterMoves `json:"moves,omitempty"`
}

type AssetControlFieldSelectEnhancementChoice struct {
	OptionType string

	Option AssetControlFieldSelectEnhancementChoiceOption

	OptionGroup AssetControlFieldSelectEnhancementChoiceOptionGroup
}

func (v AssetControlFieldSelectEnhancementChoice) MarshalJSON() ([]byte, error) {
	switch v.OptionType {
	case "option":
		return json.Marshal(struct { T string `json:"option_type"`; AssetControlFieldSelectEnhancementChoiceOption }{ v.OptionType, v.Option })
	case "option_group":
		return json.Marshal(struct { T string `json:"option_type"`; AssetControlFieldSelectEnhancementChoiceOptionGroup }{ v.OptionType, v.OptionGroup })
	}

	return nil, fmt.Errorf("bad OptionType value: %s", v.OptionType)
}

func (v *AssetControlFieldSelectEnhancementChoice) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"option_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "option":
		err = json.Unmarshal(b, &v.Option)
	case "option_group":
		err = json.Unmarshal(b, &v.OptionGroup)
	default:
		err = fmt.Errorf("bad OptionType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.OptionType = t.T
	return nil
}

// Represents an option in a list of choices.
type AssetControlFieldSelectEnhancementChoiceOption struct {
	Label InputLabel `json:"label"`

	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

type AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType string

const (
	AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionTypeOption AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType = "option"
)

// Represents an option in a list of choices.
type AssetControlFieldSelectEnhancementChoiceOptionGroupChoice struct {
	Label InputLabel `json:"label"`

	OptionType AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType `json:"option_type"`

	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

// Represents a grouping of options in a list of choices.
type AssetControlFieldSelectEnhancementChoiceOptionGroup struct {
	Choices map[string]AssetControlFieldSelectEnhancementChoiceOptionGroupChoice `json:"choices"`

	// A label for this option group.
	Name Label `json:"name"`
}

// Select from player and/or asset enhancements. Use it to describe modal
// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
// (Sundered Isles).
type AssetControlFieldSelectEnhancement struct {
	Choices map[string]AssetControlFieldSelectEnhancementChoice `json:"choices"`

	// The unique Datasworn ID for this item.
	ID AssetControlFieldID `json:"id"`

	Label InputLabel `json:"label"`

	// The key of the currently selected choice from the `choices` property, or
	// `null` if none is selected.
	Value DictKey `json:"value"`
}

type AssetControlFieldEnhancement struct {
	FieldType string

	ConditionMeter AssetControlFieldEnhancementConditionMeter
}

func (v AssetControlFieldEnhancement) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "condition_meter":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldEnhancementConditionMeter }{ v.FieldType, v.ConditionMeter })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetControlFieldEnhancement) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

// Some assets provide a special condition meter of their own. The most common
// example is the health meters on companion assets. Asset condition meters
// may also include their own controls, such as the checkboxes that Starforged
// companion assets use to indicate they are "out of action".
type AssetControlFieldEnhancementConditionMeter struct {
	// The maximum value of this meter.
	Max int8 `json:"max"`
}

// A unique ID for an AssetControlField.
type AssetControlFieldID = string

// A wildcarded ID that can be used to match multiple AssetControlFields.
type AssetControlFieldIDWildcard = string

// Describes enhancements made to this asset in a partial asset object. The
// changes should be applied recursively; only the values that are specified
// should be changed.
type AssetEnhancement struct {
	Attachments *AssetAttachment `json:"attachments,omitempty"`

	// Controls are condition meters, clocks, counters, and other asset input
	// fields whose values are expected to change throughout the life of the asset.
	Controls map[string]AssetControlFieldEnhancement `json:"controls,omitempty"`

	// If `true`, this asset counts as an impact (Starforged) or a debility
	// (classic Ironsworn).
	CountAsImpact *bool `json:"count_as_impact,omitempty"`

	// Most assets only benefit to their owner, but certain assets (like
	// Starforged's module and command vehicle assets) are shared amongst the
	// player's allies, too.
	Shared *bool `json:"shared,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

// A unique ID for an Asset.
type AssetID = string

// A wildcarded ID that can be used to match multiple Assets.
type AssetIDWildcard = string

// Options are asset input fields which are set once, usually when the character
// takes the asset. The most common example is the "name" field on companion
// assets. A more complex example is the choice of a god's stat for the Devotant
// asset.
type AssetOptionField struct {
	FieldType string

	SelectEnhancement AssetOptionFieldSelectEnhancement

	SelectValue AssetOptionFieldSelectValue

	Text AssetOptionFieldText
}

func (v AssetOptionField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "select_enhancement":
		return json.Marshal(struct { T string `json:"field_type"`; AssetOptionFieldSelectEnhancement }{ v.FieldType, v.SelectEnhancement })
	case "select_value":
		return json.Marshal(struct { T string `json:"field_type"`; AssetOptionFieldSelectValue }{ v.FieldType, v.SelectValue })
	case "text":
		return json.Marshal(struct { T string `json:"field_type"`; AssetOptionFieldText }{ v.FieldType, v.Text })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetOptionField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "select_enhancement":
		err = json.Unmarshal(b, &v.SelectEnhancement)
	case "select_value":
		err = json.Unmarshal(b, &v.SelectValue)
	case "text":
		err = json.Unmarshal(b, &v.Text)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetOptionFieldSelectEnhancementChoice struct {
	OptionType string

	Option AssetOptionFieldSelectEnhancementChoiceOption

	OptionGroup AssetOptionFieldSelectEnhancementChoiceOptionGroup
}

func (v AssetOptionFieldSelectEnhancementChoice) MarshalJSON() ([]byte, error) {
	switch v.OptionType {
	case "option":
		return json.Marshal(struct { T string `json:"option_type"`; AssetOptionFieldSelectEnhancementChoiceOption }{ v.OptionType, v.Option })
	case "option_group":
		return json.Marshal(struct { T string `json:"option_type"`; AssetOptionFieldSelectEnhancementChoiceOptionGroup }{ v.OptionType, v.OptionGroup })
	}

	return nil, fmt.Errorf("bad OptionType value: %s", v.OptionType)
}

func (v *AssetOptionFieldSelectEnhancementChoice) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"option_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "option":
		err = json.Unmarshal(b, &v.Option)
	case "option_group":
		err = json.Unmarshal(b, &v.OptionGroup)
	default:
		err = fmt.Errorf("bad OptionType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.OptionType = t.T
	return nil
}

// Represents an option in a list of choices.
type AssetOptionFieldSelectEnhancementChoiceOption struct {
	Label InputLabel `json:"label"`

	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

type AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType string

const (
	AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionTypeOption AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType = "option"
)

// Represents an option in a list of choices.
type AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice struct {
	Label InputLabel `json:"label"`

	OptionType AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType `json:"option_type"`

	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

// Represents a grouping of options in a list of choices.
type AssetOptionFieldSelectEnhancementChoiceOptionGroup struct {
	Choices map[string]AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice `json:"choices"`

	// A label for this option group.
	Name Label `json:"name"`
}

// Select from player and/or asset enhancements. Use it to describe modal
// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
// (Sundered Isles).
type AssetOptionFieldSelectEnhancement struct {
	Choices map[string]AssetOptionFieldSelectEnhancementChoice `json:"choices"`

	// The unique Datasworn ID for this item.
	ID AssetOptionFieldID `json:"id"`

	Label InputLabel `json:"label"`

	// The key of the currently selected choice from the `choices` property, or
	// `null` if none is selected.
	Value DictKey `json:"value"`
}

type AssetOptionFieldSelectValueChoice struct {
	Using string

	AssetControl AssetOptionFieldSelectValueChoiceAssetControl

	AssetOption AssetOptionFieldSelectValueChoiceAssetOption

	AttachedAssetControl AssetOptionFieldSelectValueChoiceAttachedAssetControl

	AttachedAssetOption AssetOptionFieldSelectValueChoiceAttachedAssetOption

	ConditionMeter AssetOptionFieldSelectValueChoiceConditionMeter

	Custom AssetOptionFieldSelectValueChoiceCustom

	Stat AssetOptionFieldSelectValueChoiceStat
}

func (v AssetOptionFieldSelectValueChoice) MarshalJSON() ([]byte, error) {
	switch v.Using {
	case "asset_control":
		return json.Marshal(struct { T string `json:"using"`; AssetOptionFieldSelectValueChoiceAssetControl }{ v.Using, v.AssetControl })
	case "asset_option":
		return json.Marshal(struct { T string `json:"using"`; AssetOptionFieldSelectValueChoiceAssetOption }{ v.Using, v.AssetOption })
	case "attached_asset_control":
		return json.Marshal(struct { T string `json:"using"`; AssetOptionFieldSelectValueChoiceAttachedAssetControl }{ v.Using, v.AttachedAssetControl })
	case "attached_asset_option":
		return json.Marshal(struct { T string `json:"using"`; AssetOptionFieldSelectValueChoiceAttachedAssetOption }{ v.Using, v.AttachedAssetOption })
	case "condition_meter":
		return json.Marshal(struct { T string `json:"using"`; AssetOptionFieldSelectValueChoiceConditionMeter }{ v.Using, v.ConditionMeter })
	case "custom":
		return json.Marshal(struct { T string `json:"using"`; AssetOptionFieldSelectValueChoiceCustom }{ v.Using, v.Custom })
	case "stat":
		return json.Marshal(struct { T string `json:"using"`; AssetOptionFieldSelectValueChoiceStat }{ v.Using, v.Stat })
	}

	return nil, fmt.Errorf("bad Using value: %s", v.Using)
}

func (v *AssetOptionFieldSelectValueChoice) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"using"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "asset_control":
		err = json.Unmarshal(b, &v.AssetControl)
	case "asset_option":
		err = json.Unmarshal(b, &v.AssetOption)
	case "attached_asset_control":
		err = json.Unmarshal(b, &v.AttachedAssetControl)
	case "attached_asset_option":
		err = json.Unmarshal(b, &v.AttachedAssetOption)
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	case "custom":
		err = json.Unmarshal(b, &v.Custom)
	case "stat":
		err = json.Unmarshal(b, &v.Stat)
	default:
		err = fmt.Errorf("bad Using value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.Using = t.T
	return nil
}

type AssetOptionFieldSelectValueChoiceAssetControlOptionType string

const (
	AssetOptionFieldSelectValueChoiceAssetControlOptionTypeOption AssetOptionFieldSelectValueChoiceAssetControlOptionType = "option"
)

// Represents an option in a list of choices.
type AssetOptionFieldSelectValueChoiceAssetControl struct {
	Assets []AssetIDWildcard `json:"assets"`

	// The dictionary key of the asset control field.
	Control DictKey `json:"control"`

	Label InputLabel `json:"label"`

	OptionType AssetOptionFieldSelectValueChoiceAssetControlOptionType `json:"option_type"`
}

type AssetOptionFieldSelectValueChoiceAssetOptionOptionType string

const (
	AssetOptionFieldSelectValueChoiceAssetOptionOptionTypeOption AssetOptionFieldSelectValueChoiceAssetOptionOptionType = "option"
)

// Represents an option in a list of choices.
type AssetOptionFieldSelectValueChoiceAssetOption struct {
	Assets []AssetIDWildcard `json:"assets"`

	Label InputLabel `json:"label"`

	// The dictionary key of the asset option field.
	Option DictKey `json:"option"`

	OptionType AssetOptionFieldSelectValueChoiceAssetOptionOptionType `json:"option_type"`
}

type AssetOptionFieldSelectValueChoiceAttachedAssetControlOptionType string

const (
	AssetOptionFieldSelectValueChoiceAttachedAssetControlOptionTypeOption AssetOptionFieldSelectValueChoiceAttachedAssetControlOptionType = "option"
)

// Represents an option in a list of choices.
type AssetOptionFieldSelectValueChoiceAttachedAssetControl struct {
	// The dictionary key of the asset control field.
	Control DictKey `json:"control"`

	Label InputLabel `json:"label"`

	OptionType AssetOptionFieldSelectValueChoiceAttachedAssetControlOptionType `json:"option_type"`
}

type AssetOptionFieldSelectValueChoiceAttachedAssetOptionOptionType string

const (
	AssetOptionFieldSelectValueChoiceAttachedAssetOptionOptionTypeOption AssetOptionFieldSelectValueChoiceAttachedAssetOptionOptionType = "option"
)

// Represents an option in a list of choices.
type AssetOptionFieldSelectValueChoiceAttachedAssetOption struct {
	Label InputLabel `json:"label"`

	// The dictionary key of the asset option field.
	Option DictKey `json:"option"`

	OptionType AssetOptionFieldSelectValueChoiceAttachedAssetOptionOptionType `json:"option_type"`
}

type AssetOptionFieldSelectValueChoiceConditionMeterOptionType string

const (
	AssetOptionFieldSelectValueChoiceConditionMeterOptionTypeOption AssetOptionFieldSelectValueChoiceConditionMeterOptionType = "option"
)

// Represents an option in a list of choices.
type AssetOptionFieldSelectValueChoiceConditionMeter struct {
	ConditionMeter ConditionMeterKey `json:"condition_meter"`

	Label InputLabel `json:"label"`

	OptionType AssetOptionFieldSelectValueChoiceConditionMeterOptionType `json:"option_type"`
}

type AssetOptionFieldSelectValueChoiceCustomOptionType string

const (
	AssetOptionFieldSelectValueChoiceCustomOptionTypeOption AssetOptionFieldSelectValueChoiceCustomOptionType = "option"
)

// Represents an option in a list of choices.
type AssetOptionFieldSelectValueChoiceCustom struct {
	Label InputLabel `json:"label"`

	OptionType AssetOptionFieldSelectValueChoiceCustomOptionType `json:"option_type"`

	Value int16 `json:"value"`
}

type AssetOptionFieldSelectValueChoiceStatOptionType string

const (
	AssetOptionFieldSelectValueChoiceStatOptionTypeOption AssetOptionFieldSelectValueChoiceStatOptionType = "option"
)

// Represents an option in a list of choices.
type AssetOptionFieldSelectValueChoiceStat struct {
	Label InputLabel `json:"label"`

	OptionType AssetOptionFieldSelectValueChoiceStatOptionType `json:"option_type"`

	Stat StatKey `json:"stat"`
}

// Represents a list of mutually exclusive choices.
type AssetOptionFieldSelectValue struct {
	Choices map[string]AssetOptionFieldSelectValueChoice `json:"choices"`

	// The unique Datasworn ID for this item.
	ID AssetOptionFieldID `json:"id"`

	Label InputLabel `json:"label"`

	// The key of the currently selected choice from the `choices` property, or
	// `null` if none is selected.
	Value DictKey `json:"value"`
}

// Represents an input that accepts plain text.
type AssetOptionFieldText struct {
	// The unique Datasworn ID for this item.
	ID AssetOptionFieldID `json:"id"`

	Label InputLabel `json:"label"`

	Value string `json:"value"`
}

// A unique ID for an AssetOptionField.
type AssetOptionFieldID = string

// A wildcarded ID that can be used to match multiple AssetOptionFields.
type AssetOptionFieldIDWildcard = string

type AssetType struct {
	// The unique Datasworn ID for this item.
	ID AssetTypeID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this collection.
	Color *CSSColor `json:"color,omitempty"`

	Contents map[string]Asset `json:"contents,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *AssetTypeID `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *AssetTypeID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

// A unique ID for an AssetType.
type AssetTypeID = string

type Atlas struct {
	// The unique Datasworn ID for this item.
	ID AtlasID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Collections map[string]Atlas `json:"collections,omitempty"`

	// A thematic color associated with this collection.
	Color *CSSColor `json:"color,omitempty"`

	Contents map[string]AtlasEntry `json:"contents,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *AtlasID `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *AtlasID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

// An atlas entry, like the Ironlands region entries found in classic Ironsworn.
type AtlasEntry struct {
	Description MarkdownString `json:"description"`

	Features []MarkdownString `json:"features"`

	// The unique Datasworn ID for this item.
	ID AtlasEntryID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	QuestStarter MarkdownString `json:"quest_starter"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	YourTruth *MarkdownString `json:"your_truth,omitempty"`
}

// A unique ID for an AtlasEntry.
type AtlasEntryID = string

// A wildcarded ID that can be used to match multiple AtlasEntrys.
type AtlasEntryIDWildcard = string

// A unique ID for an Atlas.
type AtlasID = string

// A wildcarded ID that can be used to match multiple Atlass.
type AtlasIDWildcard = string

// Challenge rank, represented as an integer from 1 (troublesome) to 5 (epic).
type ChallengeRank = uint8

// A basic, rollable player character resource specified by the ruleset.
type ConditionMeterKey = DictKey

// Describes a standard player character condition meter.
type ConditionMeterRule struct {
	// A description of this condition meter.
	Description MarkdownString `json:"description"`

	Label InputLabel `json:"label"`

	// The maximum value of this meter.
	Max int8 `json:"max"`

	// The minimum value of this meter.
	Min int8 `json:"min"`

	// Is this condition meter shared by all players?
	Shared bool `json:"shared"`

	// The current value of this meter.
	Value int8 `json:"value"`
}

// A unique ID for a ConditionMeterRule.
type ConditionMeterRuleID = string

// A CSS color value. See: https://developer.mozilla.org/en-
// US/docs/Web/CSS/color_value
type CSSColor = string

// A delve site with a theme, domain, and denizens.
type DelveSite struct {
	Denizens []DelveSiteDenizen `json:"denizens"`

	Description MarkdownString `json:"description"`

	Domain DelveSiteDomainID `json:"domain"`

	// The unique Datasworn ID for this item.
	ID DelveSiteID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	Rank ChallengeRank `json:"rank"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	Theme DelveSiteThemeID `json:"theme"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// An additional theme or domain card ID, for use with optional rules in
	// Ironsworn: Delve.
	ExtraCard *string `json:"extra_card,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// The ID of an atlas entry representing the region in which this delve site
	// is located.
	Region *AtlasEntryID `json:"region,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type DelveSiteDenizen struct {
	Frequency DelveSiteDenizenFrequency `json:"frequency"`

	// The unique Datasworn ID for this item.
	ID DelveSiteDenizenID `json:"id"`

	Max int16 `json:"max"`

	Min int16 `json:"min"`

	Name *Label `json:"name,omitempty"`

	// The ID of the relevant NPC entry, if one is specified.
	Npc *NpcID `json:"npc,omitempty"`
}

type DelveSiteDenizenFrequency string

const (
	DelveSiteDenizenFrequencyCommon DelveSiteDenizenFrequency = "common"

	DelveSiteDenizenFrequencyRare DelveSiteDenizenFrequency = "rare"

	DelveSiteDenizenFrequencyUncommon DelveSiteDenizenFrequency = "uncommon"

	DelveSiteDenizenFrequencyUnforeseen DelveSiteDenizenFrequency = "unforeseen"

	DelveSiteDenizenFrequencyVeryCommon DelveSiteDenizenFrequency = "very_common"
)

// A unique ID for a DelveSiteDenizen.
type DelveSiteDenizenID = string

// A delve site Domain card.
type DelveSiteDomain struct {
	Dangers []DelveSiteDomainDangerRow `json:"dangers"`

	Features []DelveSiteDomainFeatureRow `json:"features"`

	// The unique Datasworn ID for this item.
	ID DelveSiteDomainID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	Summary MarkdownString `json:"summary"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// An oracle table ID containing place name elements. For examples, see
	// oracle ID `delve/oracles/site_name/place/barrow`, and its siblings in
	// oracle collection ID `delve/collections/oracles/site_name/place`. These
	// oracles are used by the site name oracle from Ironsworn: Delve (ID:
	// delve/oracles/site_name/format) to create random names for delve sites.
	NameOracle *OracleTableID `json:"name_oracle,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

// Represents a single Danger entry from a delve site Domain card.
type DelveSiteDomainDangerRow struct {
	// The unique Datasworn ID for this item.
	ID DomainDangerRowID `json:"id"`

	// High end of the dice range for this table row.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row.
	Min int16 `json:"min"`

	// The primary text content of this row.
	Result MarkdownString `json:"result"`

	// Optional tertiary text content for this row. Generally, this is longer than
	// both `result` and `summary`.
	Description *MarkdownString `json:"description,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// Optional secondary text content for this row. Generally, this is longer
	// than `result`.
	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// Represents a single Feature entry from a delve site Domain card.
type DelveSiteDomainFeatureRow struct {
	// The unique Datasworn ID for this item.
	ID DomainFeatureRowID `json:"id"`

	// High end of the dice range for this table row.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row.
	Min int16 `json:"min"`

	// The primary text content of this row.
	Result MarkdownString `json:"result"`

	// Optional tertiary text content for this row. Generally, this is longer than
	// both `result` and `summary`.
	Description *MarkdownString `json:"description,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// Optional secondary text content for this row. Generally, this is longer
	// than `result`.
	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// A unique ID for a DelveSiteDomain.
type DelveSiteDomainID = string

// A unique ID for a DelveSite.
type DelveSiteID = string

// A delve site theme card.
type DelveSiteTheme struct {
	Dangers []DelveSiteThemeDangerRow `json:"dangers"`

	Features []DelveSiteThemeFeatureRow `json:"features"`

	// The unique Datasworn ID for this item.
	ID DelveSiteThemeID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	Summary MarkdownString `json:"summary"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

// Represents a single Danger entry from a delve site Theme card.
type DelveSiteThemeDangerRow struct {
	// The unique Datasworn ID for this item.
	ID ThemeDangerRowID `json:"id"`

	// High end of the dice range for this table row.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row.
	Min int16 `json:"min"`

	// The primary text content of this row.
	Result MarkdownString `json:"result"`

	// Optional tertiary text content for this row. Generally, this is longer than
	// both `result` and `summary`.
	Description *MarkdownString `json:"description,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// Optional secondary text content for this row. Generally, this is longer
	// than `result`.
	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// Represents a single Feature entry from a delve site Theme card.
type DelveSiteThemeFeatureRow struct {
	// The unique Datasworn ID for this item.
	ID ThemeFeatureRowID `json:"id"`

	// High end of the dice range for this table row.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row.
	Min int16 `json:"min"`

	// The primary text content of this row.
	Result MarkdownString `json:"result"`

	// Optional tertiary text content for this row. Generally, this is longer than
	// both `result` and `summary`.
	Description *MarkdownString `json:"description,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// Optional secondary text content for this row. Generally, this is longer
	// than `result`.
	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// A unique ID for a DelveSiteTheme.
type DelveSiteThemeID = string

// A simple dice roll expression with an optional modifer.
type DiceExpression = string

// A key used in a Datasworn dictionary object.
type DictKey = string

// A unique ID for a DomainDangerRow.
type DomainDangerRowID = string

// A unique ID for a DomainFeatureRow.
type DomainFeatureRowID = string

// The ID of a Datasworn package that relies on an external package to provide
// its ruleset.
type ExpansionID = string

type I18nHint struct {
	PartOfSpeech *PartOfSpeech `json:"part_of_speech,omitempty"`
}

type I18nHintsTemplate struct {
	Description *I18nHint `json:"description,omitempty"`

	Result *I18nHint `json:"result,omitempty"`

	Summary *I18nHint `json:"summary,omitempty"`
}

// Internationalization/localization hints for the text content of this object.
type I18nHints struct {
	Description *I18nHint `json:"description,omitempty"`

	Result *I18nHint `json:"result,omitempty"`

	Summary *I18nHint `json:"summary,omitempty"`

	Template *I18nHintsTemplate `json:"template,omitempty"`
}

// Describes a category of standard impacts/debilities.
type ImpactCategory struct {
	// A dictionary object of the Impacts in this category.
	Contents map[string]ImpactRule `json:"contents"`

	// A description of this impact category.
	Description MarkdownString `json:"description"`

	// A label for this impact category.
	Label Label `json:"label"`
}

// Describes a standard impact/debility.
type ImpactRule struct {
	// A description of this impact.
	Description MarkdownString `json:"description"`

	// The label for this impact.
	Label Label `json:"label"`

	// Is this impact permanent?
	Permanent bool `json:"permanent"`

	// Any ruleset condition meters that can't recover when this impact is active.
	PreventsRecovery []ConditionMeterKey `json:"prevents_recovery"`

	// Is this impact applied to all players at once?
	Shared bool `json:"shared"`
}

// A unique ID for an ImpactRuleCollection.
type ImpactRuleCollectionID = string

// A unique ID for an ImpactRule.
type ImpactRuleID = string

// A localized label for an input. In some contexts it may be undesirable to
// render this text, but it should always be exposed to assistive technology
// (e.g. with `aria-label` in HTML).
type InputLabel = string

// A localized plain text name or label.
type Label = string

// Localized text, formatted in Markdown.
// 
// It uses some custom syntax; e.g. `{{table:some_oracle_table_id}}` indicates
// that the referenced oracle table is rendered there part of the source
// material.
type MarkdownString = string

type Move struct {
	RollType string

	ActionRoll MoveActionRoll

	NoRoll MoveNoRoll

	ProgressRoll MoveProgressRoll

	SpecialTrack MoveSpecialTrack
}

func (v Move) MarshalJSON() ([]byte, error) {
	switch v.RollType {
	case "action_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveActionRoll }{ v.RollType, v.ActionRoll })
	case "no_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveNoRoll }{ v.RollType, v.NoRoll })
	case "progress_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveProgressRoll }{ v.RollType, v.ProgressRoll })
	case "special_track":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveSpecialTrack }{ v.RollType, v.SpecialTrack })
	}

	return nil, fmt.Errorf("bad RollType value: %s", v.RollType)
}

func (v *Move) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"roll_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "action_roll":
		err = json.Unmarshal(b, &v.ActionRoll)
	case "no_roll":
		err = json.Unmarshal(b, &v.NoRoll)
	case "progress_roll":
		err = json.Unmarshal(b, &v.ProgressRoll)
	case "special_track":
		err = json.Unmarshal(b, &v.SpecialTrack)
	default:
		err = fmt.Errorf("bad RollType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.RollType = t.T
	return nil
}

// A move that makes an action roll.
type MoveActionRoll struct {
	// The unique Datasworn ID for this item.
	ID MoveID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerActionRoll `json:"trigger"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// Oracles associated with this move. It's not recommended to roll these
	// automatically, as almost all moves present them as an option, not a
	// requirement.
	Oracles []OracleTableID `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified move. References to the
	// replaced move can be considered equivalent to this move.
	Replaces *MoveID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

// A move that makes no progress rolls or action rolls.
type MoveNoRoll struct {
	// The unique Datasworn ID for this item.
	ID MoveID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerNoRoll `json:"trigger"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// Oracles associated with this move. It's not recommended to roll these
	// automatically, as almost all moves present them as an option, not a
	// requirement.
	Oracles []OracleTableID `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified move. References to the
	// replaced move can be considered equivalent to this move.
	Replaces *MoveID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

// A progress move that rolls on a standard progress track type (whose features
// are defined by this move object). For progress rolls that use special tracks,
// see MoveSpecialTrack.
type MoveProgressRoll struct {
	// The unique Datasworn ID for this item.
	ID MoveID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Describes the common features of progress tracks associated with this move.
	Tracks ProgressTrackTypeInfo `json:"tracks"`

	// Trigger conditions for this move.
	Trigger TriggerProgressRoll `json:"trigger"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// Oracles associated with this move. It's not recommended to roll these
	// automatically, as almost all moves present them as an option, not a
	// requirement.
	Oracles []OracleTableID `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified move. References to the
	// replaced move can be considered equivalent to this move.
	Replaces *MoveID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

// A progress move that rolls on a special track, such as Legacies (Starforged)
// or Bonds (classic Ironsworn). For progress moves that use standard progress
// tracks, see MoveProgressRoll instead.
type MoveSpecialTrack struct {
	// The unique Datasworn ID for this item.
	ID MoveID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Trigger conditions for this move.
	Trigger TriggerSpecialTrack `json:"trigger"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// Oracles associated with this move. It's not recommended to roll these
	// automatically, as almost all moves present them as an option, not a
	// requirement.
	Oracles []OracleTableID `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified move. References to the
	// replaced move can be considered equivalent to this move.
	Replaces *MoveID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type MoveCategory struct {
	// The unique Datasworn ID for this item.
	ID MoveCategoryID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this collection.
	Color *CSSColor `json:"color,omitempty"`

	Contents map[string]Move `json:"contents,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *MoveCategoryID `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *MoveCategoryID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

// A unique ID for a MoveCategory.
type MoveCategoryID = string

type MoveEnhancement struct {
	RollType string

	ActionRoll MoveEnhancementActionRoll

	NoRoll MoveEnhancementNoRoll

	ProgressRoll MoveEnhancementProgressRoll

	SpecialTrack MoveEnhancementSpecialTrack
}

func (v MoveEnhancement) MarshalJSON() ([]byte, error) {
	switch v.RollType {
	case "action_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementActionRoll }{ v.RollType, v.ActionRoll })
	case "no_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementNoRoll }{ v.RollType, v.NoRoll })
	case "progress_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementProgressRoll }{ v.RollType, v.ProgressRoll })
	case "special_track":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementSpecialTrack }{ v.RollType, v.SpecialTrack })
	}

	return nil, fmt.Errorf("bad RollType value: %s", v.RollType)
}

func (v *MoveEnhancement) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"roll_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "action_roll":
		err = json.Unmarshal(b, &v.ActionRoll)
	case "no_roll":
		err = json.Unmarshal(b, &v.NoRoll)
	case "progress_roll":
		err = json.Unmarshal(b, &v.ProgressRoll)
	case "special_track":
		err = json.Unmarshal(b, &v.SpecialTrack)
	default:
		err = fmt.Errorf("bad RollType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.RollType = t.T
	return nil
}

// An object that describes changes to a move. These changes should be applied
// recursively, altering only the specified properties; enhanced arrays should
// be concatencated with the original array value.
type MoveEnhancementActionRoll struct {
	Enhances []MoveIDWildcard `json:"enhances"`

	Trigger *TriggerActionRollEnhancement `json:"trigger,omitempty"`
}

// An object that describes changes to a move. These changes should be applied
// recursively, altering only the specified properties; enhanced arrays should
// be concatencated with the original array value.
type MoveEnhancementNoRoll struct {
	Enhances []MoveIDWildcard `json:"enhances"`

	Trigger *TriggerNoRollEnhancement `json:"trigger,omitempty"`
}

// An object that describes changes to a move. These changes should be applied
// recursively, altering only the specified properties; enhanced arrays should
// be concatencated with the original array value.
type MoveEnhancementProgressRoll struct {
	Enhances []MoveIDWildcard `json:"enhances"`

	Trigger *TriggerProgressRollEnhancement `json:"trigger,omitempty"`
}

// An object that describes changes to a move. These changes should be applied
// recursively, altering only the specified properties; enhanced arrays should
// be concatencated with the original array value.
type MoveEnhancementSpecialTrack struct {
	Enhances []MoveIDWildcard `json:"enhances"`

	Trigger *TriggerSpecialTrackEnhancement `json:"trigger,omitempty"`
}

// A move ID, for a standard move or a unique asset move
type MoveID = string

// A move ID with wildcards.
type MoveIDWildcard = string

type MoveOutcome struct {
	Text MarkdownString `json:"text"`
}

type MoveOutcomeType string

const (
// The score doesn't beat either challenge die.
	MoveOutcomeTypeMiss MoveOutcomeType = "miss"

// The score is greater than both challenge dice.
	MoveOutcomeTypeStrongHit MoveOutcomeType = "strong_hit"

// The score is greater than one challenge die.
	MoveOutcomeTypeWeakHit MoveOutcomeType = "weak_hit"
)

// A standalone localized description for each move outcome (miss, weak hit,
// or strong hit). This is for for e.g. VTT implementations, where it's often
// useful to display only the rules text relevant to a roll result.
// 
//   This often requires light editorialization to create text that can stand
// alone without reference to the rest of the move. For example, 'as above'
// (in reference to another move outcome) shouldn't be used here; instead, the
// relevant text should be repeated.
type MoveOutcomes struct {
	Miss MoveOutcome `json:"miss"`

	StrongHit MoveOutcome `json:"strong_hit"`

	WeakHit MoveOutcome `json:"weak_hit"`
}

type MoveRollType string

const (
// A move that makes an action roll.
	MoveRollTypeActionRoll MoveRollType = "action_roll"

// A move that makes no action rolls or progress rolls.
	MoveRollTypeNoRoll MoveRollType = "no_roll"

// A progress move that rolls on a standard progress track type (defined by
// this move).
	MoveRollTypeProgressRoll MoveRollType = "progress_roll"

// A progress move that rolls on one or more special tracks, like Bonds (classic
// Ironsworn), Failure (Delve), or Legacies (Starforged).
	MoveRollTypeSpecialTrack MoveRollType = "special_track"
)

// A non-player character entry, similar to those in Chapter 5 of the Ironsworn
// Rulebook, or Chapter 4 of Starforged.
type Npc struct {
	Description MarkdownString `json:"description"`

	Drives []MarkdownString `json:"drives"`

	Features []MarkdownString `json:"features"`

	// The unique Datasworn ID for this item.
	ID NpcID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	Nature NpcNature `json:"nature"`

	QuestStarter MarkdownString `json:"quest_starter"`

	// The suggested challenge rank for this NPC.
	Rank ChallengeRank `json:"rank"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	Tactics []MarkdownString `json:"tactics"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Variants map[string]NpcVariant `json:"variants,omitempty"`

	YourTruth *MarkdownString `json:"your_truth,omitempty"`
}

type NpcCollection struct {
	// The unique Datasworn ID for this item.
	ID NpcCollectionID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this collection.
	Color *CSSColor `json:"color,omitempty"`

	Contents map[string]Npc `json:"contents,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *NpcCollectionID `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *NpcCollectionID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

// A unique ID for a NpcCollection.
type NpcCollectionID = string

// A unique ID for a Npc.
type NpcID = string

// A wildcarded ID that can be used to match multiple Npcs.
type NpcIDWildcard = string

// A localized category label describing the nature of this NPC.
// 
// In Ironsworn classic, this is probably the singular form of the parent
// collection's name.
// 
// For Starforged, see the table on p. 258 for examples.
type NpcNature = Label

type NpcVariant struct {
	Description MarkdownString `json:"description"`

	// The unique Datasworn ID for this item.
	ID NpcVariantID `json:"id"`

	Name Label `json:"name"`

	Nature NpcNature `json:"nature"`

	// The suggested challenge rank for this NPC.
	Rank ChallengeRank `json:"rank"`

	Summary *MarkdownString `json:"summary,omitempty"`
}

// A unique ID for a NpcVariant.
type NpcVariantID = string

type OracleCollection struct {
	// The unique Datasworn ID for this item.
	ID OracleCollectionID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Collections map[string]OracleCollection `json:"collections,omitempty"`

	// A thematic color associated with this collection.
	Color *CSSColor `json:"color,omitempty"`

	Contents map[string]OracleTable `json:"contents,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *OracleCollectionID `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Rendering *OracleCollectionRendering `json:"rendering,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *OracleCollectionID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

// A unique ID for an OracleCollection.
type OracleCollectionID = string

// Describes the presentation of this oracle collection, which might represent a
// group of separate tables, or a single table with additional columns.
type OracleCollectionRendering struct {
	Style string

	MultiTable OracleCollectionRenderingMultiTable

	Tables OracleCollectionRenderingTables
}

func (v OracleCollectionRendering) MarshalJSON() ([]byte, error) {
	switch v.Style {
	case "multi_table":
		return json.Marshal(struct { T string `json:"style"`; OracleCollectionRenderingMultiTable }{ v.Style, v.MultiTable })
	case "tables":
		return json.Marshal(struct { T string `json:"style"`; OracleCollectionRenderingTables }{ v.Style, v.Tables })
	}

	return nil, fmt.Errorf("bad Style value: %s", v.Style)
}

func (v *OracleCollectionRendering) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"style"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "multi_table":
		err = json.Unmarshal(b, &v.MultiTable)
	case "tables":
		err = json.Unmarshal(b, &v.Tables)
	default:
		err = fmt.Errorf("bad Style value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.Style = t.T
	return nil
}

type OracleCollectionRenderingMultiTable struct {
	Columns map[string]OracleCollectionTableColumn `json:"columns"`
}

type OracleCollectionRenderingTables struct {
}

type OracleCollectionStyle string

const (
// Presented as a single table, with its OracleTable children rendered as
// columns.
	OracleCollectionStyleMultiTable OracleCollectionStyle = "multi_table"

// Presented as a collection of separate tables.
	OracleCollectionStyleTables OracleCollectionStyle = "tables"
)

type OracleCollectionTableColumn struct {
	ContentType OracleTableColumnContentKey `json:"content_type"`

	// The column's header text.
	Label Label `json:"label"`

	// The key of the OracleTable (within this collection), whose data is used to
	// render this column.
	TableKey DictKey `json:"table_key"`

	// The thematic color for this column.
	Color *CSSColor `json:"color,omitempty"`
}

// Provides string templates that may be used in place of the static
// row text from `OracleTableRow#result`, `OracleTableRow#summary`, and
// `OracleTableRow#description`.
// 
//   These strings are formatted in Markdown, but use a special syntax for their
// placeholders: `{{result:some_oracle_table_id}}`. The placeholder should be
// replaced with the value of a rolled (or selected) `OracleTableRow#result`
// from the target oracle table ID.
type OracleRollTemplate struct {
	// A string template that may be used in place of OracleTableRow#description.
	Description *TemplateString `json:"description,omitempty"`

	// A string template that may be used in place of OracleTableRow#result.
	Result *TemplateString `json:"result,omitempty"`

	// A string template that may be used in place of OracleTableRow#summary.
	Summary *TemplateString `json:"summary,omitempty"`
}

// Represents a single oracle table, or a single table column of a table that
// has multiple "Roll" or "Result" columns.
type OracleTable struct {
	// The roll used to select a result on this table.
	Dice DiceExpression `json:"dice"`

	// The unique Datasworn ID for this item.
	ID OracleTableID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	Table []OracleTableRow `json:"table"`

	I18n *I18nHints `json:"_i18n,omitempty"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A longer description of the oracle table's intended usage, which might
	// include multiple paragraphs. If it's only a couple sentences, use the
	// `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// An icon that represents this table.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleTableMatchBehavior `json:"match,omitempty"`

	// Describes how how to render this table, when presenting it as a standalone
	// table.
	Rendering *OracleTableRendering `json:"rendering,omitempty"`

	// Indicates that this table replaces the identified table. References to the
	// replaced table can be considered equivalent to this table.
	Replaces *OracleTableID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of the oracle table's intended usage, no more than a few
	// sentences in length. This is intended for use in application tooltips
	// and similar sorts of hints. Longer text should use the "description" key
	// instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

type OracleTableColumn struct {
	ContentType OracleTableColumnContentKey `json:"content_type"`

	// The column's header text.
	Label Label `json:"label"`

	// The thematic color for this column.
	Color *CSSColor `json:"color,omitempty"`
}

// The value(s) from each OracleTableRow that is rendered in this column.
type OracleTableColumnContentKey string

const (
// Column displays the OracleTableRow's `description` key.
	OracleTableColumnContentKeyDescription OracleTableColumnContentKey = "description"

// Column displays the OracleTableRow's `result` key.
	OracleTableColumnContentKeyResult OracleTableColumnContentKey = "result"

// Column displays the roll range (`min` and `max`) of each OracleTableRow.
	OracleTableColumnContentKeyRoll OracleTableColumnContentKey = "roll"

// Column displays the OracleTableRow's `summary` key.
	OracleTableColumnContentKeySummary OracleTableColumnContentKey = "summary"
)

// A unique ID for an OracleTable.
type OracleTableID = string

// Oracle table wildcards can also use '**' to represent any number of
// collection levels in the oracle tree.
type OracleTableIDWildcard = string

type OracleTableMatchBehavior struct {
	Text MarkdownString `json:"text"`
}

// Describes the presentation of this table.
type OracleTableRendering struct {
	Style string

	Column OracleTableRenderingColumn

	EmbedInRow OracleTableRenderingEmbedInRow

	Standalone OracleTableRenderingStandalone
}

func (v OracleTableRendering) MarshalJSON() ([]byte, error) {
	switch v.Style {
	case "column":
		return json.Marshal(struct { T string `json:"style"`; OracleTableRenderingColumn }{ v.Style, v.Column })
	case "embed_in_row":
		return json.Marshal(struct { T string `json:"style"`; OracleTableRenderingEmbedInRow }{ v.Style, v.EmbedInRow })
	case "standalone":
		return json.Marshal(struct { T string `json:"style"`; OracleTableRenderingStandalone }{ v.Style, v.Standalone })
	}

	return nil, fmt.Errorf("bad Style value: %s", v.Style)
}

func (v *OracleTableRendering) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"style"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "column":
		err = json.Unmarshal(b, &v.Column)
	case "embed_in_row":
		err = json.Unmarshal(b, &v.EmbedInRow)
	case "standalone":
		err = json.Unmarshal(b, &v.Standalone)
	default:
		err = fmt.Errorf("bad Style value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.Style = t.T
	return nil
}

type OracleTableRenderingColumn struct {
}

type OracleTableRenderingEmbedInRow struct {
}

type OracleTableRenderingStandalone struct {
	Columns map[string]OracleTableColumn `json:"columns"`
}

type OracleTableRoll struct {
	// Both Ironsworn and Starforged explicitly recommend *against* rolling
	// all details at once. That said, some oracle results only provide useful
	// information once a secondary roll occurs, such as "Action + Theme".
	Auto bool `json:"auto"`

	Dice DiceExpression `json:"dice"`

	// Special rules on how the oracle table roll is performed.
	Method OracleTableRollMethod `json:"method"`

	Oracle OracleTableID `json:"oracle"`

	// The number of times to roll.
	Times int16 `json:"times"`
}

// Special roll instructions to use when rolling multiple times on a single
// oracle table.
type OracleTableRollMethod string

const (
// Duplicates should be kept.
	OracleTableRollMethodKeepDuplicates OracleTableRollMethod = "keep_duplicates"

// Duplicates should be kept, and they compound to make things worse.
	OracleTableRollMethodMakeItWorse OracleTableRollMethod = "make_it_worse"

// Duplicates should be re-rolled.
	OracleTableRollMethodNoDuplicates OracleTableRollMethod = "no_duplicates"
)

// Represents a row in an oracle table.
type OracleTableRow struct {
	// The unique Datasworn ID for this item.
	ID OracleTableRowID `json:"id"`

	// High end of the dice range for this table row.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row.
	Min int16 `json:"min"`

	// The primary text content of this row.
	Result MarkdownString `json:"result"`

	// Optional tertiary text content for this row. Generally, this is longer than
	// both `result` and `summary`.
	Description *MarkdownString `json:"description,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// Optional secondary text content for this row. Generally, this is longer
	// than `result`.
	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// Normally, rows will end with two numbers separated by a dash, indicating
// their dice range.
// 
// Rows with a single number represent unrollable rows that are sometimes
// included for rendering purposes; in this case, the number represents the
// row's index.
type OracleTableRowID = string

type OracleTableStyle string

const (
// Render as a single column of a table.
	OracleTableStyleColumn OracleTableStyle = "column"

// Render as a table, within a row in another table.
	OracleTableStyleEmbedInRow OracleTableStyle = "embed_in_row"

// Render as a standalone table.
	OracleTableStyleStandalone OracleTableStyle = "standalone"
)

type PartOfSpeech string

const (
// An adjective.
	PartOfSpeechAdjective PartOfSpeech = "adjective"

// A common noun used as an adjective, to modify another noun.
	PartOfSpeechAdjunctCommonNoun PartOfSpeech = "adjunct_common_noun"

// A proper noun used as an adjective, to modify another noun.
	PartOfSpeechAdjunctProperNoun PartOfSpeech = "adjunct_proper_noun"

// A verb used as an adjective, to modify a noun.
	PartOfSpeechAttributiveVerb PartOfSpeech = "attributive_verb"

// A common noun.
	PartOfSpeechCommonNoun PartOfSpeech = "common_noun"

// Gerund or present participle of a verb, e.g. "going", "seeing", "waving"
	PartOfSpeechGerund PartOfSpeech = "gerund"

// A proper noun.
	PartOfSpeechProperNoun PartOfSpeech = "proper_noun"

// A verb in present tense
	PartOfSpeechVerb PartOfSpeech = "verb"
)

type ProgressRollMethod string

const (
// An automatic miss.
	ProgressRollMethodMiss ProgressRollMethod = "miss"

// Make a progress roll on a progress track associated with this move.
	ProgressRollMethodProgressRoll ProgressRollMethod = "progress_roll"

// An automatic strong hit.
	ProgressRollMethodStrongHit ProgressRollMethod = "strong_hit"

// An automatic weak hit.
	ProgressRollMethodWeakHit ProgressRollMethod = "weak_hit"
)

type ProgressRollOptionUsing string

const (
	ProgressRollOptionUsingProgressTrack ProgressRollOptionUsing = "progress_track"
)

type ProgressRollOption struct {
	Using ProgressRollOptionUsing `json:"using"`
}

// Describes the features of a type of progress track.
type ProgressTrackTypeInfo struct {
	// A category label for progress tracks of this type.
	Category Label `json:"category"`

	Controls map[string]interface{} `json:"controls,omitempty"`
}

// A rarity, as described in Ironsworn: Delve.
type Rarity struct {
	// The asset augmented by this rarity.
	Asset AssetID `json:"asset"`

	Description MarkdownString `json:"description"`

	// The unique Datasworn ID for this item.
	ID RarityID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// From Ironsworn: Delve, p. 174:
	// 
	//       Some assets will bring a rarity into play more often than others, so
	// the experience point cost for a rarity will vary by the linked asset. These
	// costs are shown in the tables on page 175.
	// 
	//       If you are playing solo, and arent concerned with the relative
	// balance of rarity abilities, you can ignore these variable costs. If so,
	// spend 3 experience points to purchase a rarity.
	XpCost int16 `json:"xp_cost"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

// A unique ID for a Rarity.
type RarityID = string

type RollableValue struct {
	Using string

	AssetControl RollableValueAssetControl

	AssetOption RollableValueAssetOption

	AttachedAssetControl RollableValueAttachedAssetControl

	AttachedAssetOption RollableValueAttachedAssetOption

	ConditionMeter RollableValueConditionMeter

	Custom RollableValueCustom

	Stat RollableValueStat
}

func (v RollableValue) MarshalJSON() ([]byte, error) {
	switch v.Using {
	case "asset_control":
		return json.Marshal(struct { T string `json:"using"`; RollableValueAssetControl }{ v.Using, v.AssetControl })
	case "asset_option":
		return json.Marshal(struct { T string `json:"using"`; RollableValueAssetOption }{ v.Using, v.AssetOption })
	case "attached_asset_control":
		return json.Marshal(struct { T string `json:"using"`; RollableValueAttachedAssetControl }{ v.Using, v.AttachedAssetControl })
	case "attached_asset_option":
		return json.Marshal(struct { T string `json:"using"`; RollableValueAttachedAssetOption }{ v.Using, v.AttachedAssetOption })
	case "condition_meter":
		return json.Marshal(struct { T string `json:"using"`; RollableValueConditionMeter }{ v.Using, v.ConditionMeter })
	case "custom":
		return json.Marshal(struct { T string `json:"using"`; RollableValueCustom }{ v.Using, v.Custom })
	case "stat":
		return json.Marshal(struct { T string `json:"using"`; RollableValueStat }{ v.Using, v.Stat })
	}

	return nil, fmt.Errorf("bad Using value: %s", v.Using)
}

func (v *RollableValue) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"using"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "asset_control":
		err = json.Unmarshal(b, &v.AssetControl)
	case "asset_option":
		err = json.Unmarshal(b, &v.AssetOption)
	case "attached_asset_control":
		err = json.Unmarshal(b, &v.AttachedAssetControl)
	case "attached_asset_option":
		err = json.Unmarshal(b, &v.AttachedAssetOption)
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	case "custom":
		err = json.Unmarshal(b, &v.Custom)
	case "stat":
		err = json.Unmarshal(b, &v.Stat)
	default:
		err = fmt.Errorf("bad Using value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.Using = t.T
	return nil
}

// A reference to the value of an asset control.
type RollableValueAssetControl struct {
	Assets []AssetIDWildcard `json:"assets"`

	// The dictionary key of the asset control field.
	Control DictKey `json:"control"`
}

// A reference to the value of an asset option.
type RollableValueAssetOption struct {
	Assets []AssetIDWildcard `json:"assets"`

	// The dictionary key of the asset option field.
	Option DictKey `json:"option"`
}

// A reference to the value of an attached asset control. For example, a Module
// asset could use this to roll using the `integrity` control of an attached
// Vehicle.
type RollableValueAttachedAssetControl struct {
	// The dictionary key of the asset control field.
	Control DictKey `json:"control"`
}

// A reference to the value of an attached asset option.
type RollableValueAttachedAssetOption struct {
	// The dictionary key of the asset option field.
	Option DictKey `json:"option"`
}

// A reference to the value of a standard player condition meter.
type RollableValueConditionMeter struct {
	ConditionMeter ConditionMeterKey `json:"condition_meter"`
}

// An arbitrary static integer value with a label.
type RollableValueCustom struct {
	Label Label `json:"label"`

	Value int16 `json:"value"`
}

// A reference to the value of a standard player character stat.
type RollableValueStat struct {
	Stat StatKey `json:"stat"`
}

type RollableValueType string

const (
// A reference to the value of an asset control.
	RollableValueTypeAssetControl RollableValueType = "asset_control"

// A reference to the value of an asset option.
	RollableValueTypeAssetOption RollableValueType = "asset_option"

// A reference to the value of an attached asset control. For example, a Module
// asset could use this to roll using the `integrity` control of an attached
// Vehicle.
	RollableValueTypeAttachedAssetControl RollableValueType = "attached_asset_control"

// A reference to the value of an attached asset option.
	RollableValueTypeAttachedAssetOption RollableValueType = "attached_asset_option"

// A reference to the value of a standard player condition meter.
	RollableValueTypeConditionMeter RollableValueType = "condition_meter"

// An arbitrary static integer value with a label.
	RollableValueTypeCustom RollableValueType = "custom"

// A reference to the value of a standard player character stat.
	RollableValueTypeStat RollableValueType = "stat"
)

// Describes rules for player characters in this ruleset, such as stats and
// condition meters.
type Rules struct {
	// Describes the standard condition meters used by player characters in this
	// ruleset.
	ConditionMeters map[string]ConditionMeterRule `json:"condition_meters"`

	// Describes the standard impacts/debilities used by player characters in this
	// ruleset.
	Impacts map[string]ImpactCategory `json:"impacts"`

	// Describes the special tracks used by player characters in this ruleset, like
	// Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
	SpecialTracks map[string]SpecialTrackRule `json:"special_tracks"`

	// Describes the standard stats used by player characters in this ruleset.
	Stats map[string]StatRule `json:"stats"`
}

// Describes rules for player characters in this ruleset, such as stats and
// condition meters.
type RulesExpansion struct {
	// Describes the standard condition meters used by player characters in this
	// ruleset.
	ConditionMeters map[string]ConditionMeterRule `json:"condition_meters,omitempty"`

	// Describes the standard impacts/debilities used by player characters in this
	// ruleset.
	Impacts map[string]ImpactCategory `json:"impacts,omitempty"`

	// Describes the special tracks used by player characters in this ruleset, like
	// Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
	SpecialTracks map[string]SpecialTrackRule `json:"special_tracks,omitempty"`

	// Describes the standard stats used by player characters in this ruleset.
	Stats map[string]StatRule `json:"stats,omitempty"`
}

// The ID of standalone Datasworn package that describes its own ruleset.
type RulesetID = string

type SemanticVersion = string

type SourceAuthor struct {
	Name string `json:"name"`

	// An optional email contact for the author
	Email *string `json:"email,omitempty"`

	// An optional URL for the author's website.
	URL *string `json:"url,omitempty"`
}

// Metadata describing the original source of this item
type Source struct {
	Authors []SourceAuthor `json:"authors"`

	// The date of the source documents's last update, formatted YYYY-MM-DD.
	// Required because it's used to determine whether the data needs updating.
	Date string `json:"date"`

	License string `json:"license"`

	// The title of the source document.
	Title string `json:"title"`

	// An absolute URL where the source document is available.
	URL string `json:"url"`

	// The page number where this item is described in full.
	Page *int16 `json:"page,omitempty"`
}

type SpecialTrackRollMethod string

const (
// Use **every** roll option at once.
	SpecialTrackRollMethodAll SpecialTrackRollMethod = "all"

// Use the roll option with the best/highest value.
	SpecialTrackRollMethodHighest SpecialTrackRollMethod = "highest"

// Use the roll option with the worst/lowest value.
	SpecialTrackRollMethodLowest SpecialTrackRollMethod = "lowest"

// An automatic miss.
	SpecialTrackRollMethodMiss SpecialTrackRollMethod = "miss"

// The player chooses which roll option to use.
	SpecialTrackRollMethodPlayerChoice SpecialTrackRollMethod = "player_choice"

// An automatic strong hit.
	SpecialTrackRollMethodStrongHit SpecialTrackRollMethod = "strong_hit"

// An automatic weak hit.
	SpecialTrackRollMethodWeakHit SpecialTrackRollMethod = "weak_hit"
)

// Describes a special track like Bonds (classic Ironsworn), Failure (Delve), or
// Legacies (Starforged).
type SpecialTrackRule struct {
	// A description of this special track.
	Description MarkdownString `json:"description"`

	// A label for this special track.
	Label Label `json:"label"`

	// Is this track an optional rule?
	Optional bool `json:"optional"`

	// Is this track shared by all players?
	Shared bool `json:"shared"`
}

// A unique ID for a SpecialTrackRule.
type SpecialTrackRuleID = string

// Special, ruleset-specific progress tracks. Usually, one exists per player
// character, and they persist through the life of the player character.
// 'Canonical' examples:
//   * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
// legacy track, use `bonds_legacy` instead.
//   * `failure_track`, described in Ironsworn: Delve
//   * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
// Ironsworn: Starforged
// 
type SpecialTrackType = DictKey

// A basic player character stat.
type StatKey = DictKey

// Describes a standard player character stat.
type StatRule struct {
	// A description of this stat.
	Description MarkdownString `json:"description"`

	// A label for this stat.
	Label Label `json:"label"`
}

// A unique ID for a StatRule.
type StatRuleID = string

type Suggestions struct {
	Assets []AssetID `json:"assets,omitempty"`

	Atlas []AtlasEntryID `json:"atlas,omitempty"`

	Moves []MoveID `json:"moves,omitempty"`

	Npcs []NpcID `json:"npcs,omitempty"`

	Oracles []OracleTableID `json:"oracles,omitempty"`

	Rarities []RarityID `json:"rarities,omitempty"`

	SiteDomains []DelveSiteDomainID `json:"site_domains,omitempty"`

	SiteThemes []DelveSiteThemeID `json:"site_themes,omitempty"`
}

// A relative URL pointing to a vector image in the SVG format.
type SvgImageURL = string

// A rich text string in Markdown with replaced values from oracle roll results.
// 
// The custom syntax `{{some_row_key:some_oracle_table_id}}` should be replaced
// by the `some_row_key` string of a rolled oracle table. This is usually the
// `result` key, for example `{{result:starforged/oracles/core/action}}`
type TemplateString = string

// A unique ID for a ThemeDangerRow.
type ThemeDangerRowID = string

// A unique ID for a ThemeFeatureRow.
type ThemeFeatureRowID = string

// Describes trigger conditions for a move that makes an action roll.
type TriggerActionRoll struct {
	// Specific conditions that qualify for this trigger.
	Conditions []TriggerActionRollCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerActionRollCondition struct {
	Method ActionRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []RollableValue `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerActionRollConditionEnhancement struct {
	Method ActionRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []RollableValue `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

// Describes changes/additions made to the enhanced move's trigger conditions.
type TriggerActionRollEnhancement struct {
	// Trigger conditions added to the enhanced move.
	Conditions []TriggerActionRollConditionEnhancement `json:"conditions"`
}

// Information on who can trigger this trigger condition. Usually this is just
// the player, but some asset abilities can trigger from an ally's move.
type TriggerBy struct {
	// Can this trigger be activated by one of the player's allies?
	Ally bool `json:"ally"`

	// Can this trigger be activated by the player who owns this?
	Player bool `json:"player"`
}

// Describes trigger conditions for a move that makes no rolls.
type TriggerNoRoll struct {
	Conditions []TriggerNoRollCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerNoRollCondition struct {
	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

// Describes changes/additions made to the enhanced move's trigger conditions.
type TriggerNoRollEnhancement struct {
	// Trigger conditions added to the enhanced move.
	Conditions []TriggerNoRollCondition `json:"conditions"`
}

type TriggerProgressRoll struct {
	// Specific conditions that qualify for this trigger.
	Conditions []TriggerProgressRollCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerProgressRollCondition struct {
	Method ProgressRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []ProgressRollOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerProgressRollConditionEnhancement struct {
	Method ProgressRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []ProgressRollOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

// Describes changes/additions made to the enhanced move's trigger conditions.
type TriggerProgressRollEnhancement struct {
	// Trigger conditions added to the enhanced move.
	Conditions []TriggerProgressRollConditionEnhancement `json:"conditions"`
}

type TriggerSpecialTrack struct {
	// Specific conditions that qualify for this trigger.
	Conditions []TriggerSpecialTrackCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerSpecialTrackCondition struct {
	Method SpecialTrackRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []TriggerSpecialTrackConditionOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

// A progress move that rolls on one or more special tracks, like Bonds (classic
// Ironsworn), Failure (Delve), or Legacy (Starforged).
type TriggerSpecialTrackConditionEnhancement struct {
	Method SpecialTrackRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []TriggerSpecialTrackConditionOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerSpecialTrackConditionOption struct {
	Using SpecialTrackType `json:"using"`
}

// Describes changes/additions made to the enhanced move's trigger conditions.
type TriggerSpecialTrackEnhancement struct {
	// Trigger conditions added to the enhanced move.
	Conditions []TriggerSpecialTrackConditionEnhancement `json:"conditions"`
}

// A setting truth category.
type Truth struct {
	// The unique Datasworn ID for this item.
	ID TruthID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	Options []TruthOption `json:"options"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	YourCharacter *MarkdownString `json:"your_character,omitempty"`
}

// A unique ID for a Truth.
type TruthID = string

type TruthOption struct {
	Description MarkdownString `json:"description"`

	// The unique Datasworn ID for this item.
	ID TruthOptionID `json:"id"`

	QuestStarter MarkdownString `json:"quest_starter"`

	Max *int16 `json:"max,omitempty"`

	Min *int16 `json:"min,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Table []TruthOptionTableRow `json:"table,omitempty"`
}

// A unique ID for a TruthOption.
type TruthOptionID = string

// Represents a row in an oracle table.
type TruthOptionTableRow struct {
	// High end of the dice range for this table row.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row.
	Min int16 `json:"min"`

	// The primary text content of this row.
	Result MarkdownString `json:"result"`

	// Optional tertiary text content for this row. Generally, this is longer than
	// both `result` and `summary`.
	Description *MarkdownString `json:"description,omitempty"`

	// Hints that the identified table should be rendered inside this table row.
	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Further oracle rolls prompted by this table row.
	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// Optional secondary text content for this row. Generally, this is longer
	// than `result`.
	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// A relative URL pointing to a raster image in the WEBP format.
type WebpImageURL = string
