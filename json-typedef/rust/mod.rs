// Code generated by jtd-codegen for Rust v0.2.1

use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

/// Describes game rules compatible with the Ironsworn tabletop role-playing
/// game by Shawn Tomkin.
#[derive(Serialize, Deserialize)]
#[serde(tag = "package_type")]
pub enum RulesPackage {
    #[serde(rename = "expansion")]
    Expansion(RulesPackageExpansion),

    #[serde(rename = "ruleset")]
    Ruleset(RulesPackageRuleset),
}

/// A Datasworn package that relies on an external package to provide its
/// ruleset.
#[derive(Serialize, Deserialize)]
pub struct RulesPackageExpansion {
    /// The version of the Datasworn format used by this data.
    #[serde(rename = "datasworn_version")]
    pub dataswornVersion: SemanticVersion,

    #[serde(rename = "id")]
    pub id: ExpansionId,

    #[serde(rename = "ruleset")]
    pub ruleset: RulesetId,

    /// A dictionary object containing asset types, which contain assets.
    #[serde(rename = "assets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assets: Option<Box<HashMap<String, AssetType>>>,

    /// A dictionary object containing atlas collections, which contain atlas
    /// entries.
    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<HashMap<String, Atlas>>>,

    /// A dictionary object of delve sites, like the premade delve sites
    /// presented in Ironsworn: Delve
    #[serde(rename = "delve_sites")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delveSites: Option<Box<HashMap<String, DelveSite>>>,

    /// A dictionary object containing move categories, which contain moves.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<HashMap<String, MoveCategory>>>,

    /// A dictionary object containing NPC collections, which contain NPCs.
    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<HashMap<String, NpcCollection>>>,

    /// A dictionary object containing oracle collections, which may contain
    /// oracle tables and/or oracle collections.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, OracleCollection>>>,

    /// A dictionary object containing rarities, like those presented in
    /// Ironsworn: Delve.
    #[serde(rename = "rarities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rarities: Option<Box<HashMap<String, Rarity>>>,

    #[serde(rename = "rules")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rules: Option<Box<RulesExpansion>>,

    /// A dictionary object containing delve site domains.
    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<HashMap<String, DelveSiteDomain>>>,

    /// A dictionary object containing delve site themes.
    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<HashMap<String, DelveSiteTheme>>>,

    /// A dictionary object of truth categories.
    #[serde(rename = "truths")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truths: Option<Box<HashMap<String, Truth>>>,
}

/// A standalone Datasworn package that describes its own ruleset.
#[derive(Serialize, Deserialize)]
pub struct RulesPackageRuleset {
    /// A dictionary object containing asset types, which contain assets.
    #[serde(rename = "assets")]
    pub assets: HashMap<String, AssetType>,

    /// The version of the Datasworn format used by this data.
    #[serde(rename = "datasworn_version")]
    pub dataswornVersion: SemanticVersion,

    #[serde(rename = "id")]
    pub id: RulesetId,

    /// A dictionary object containing move categories, which contain moves.
    #[serde(rename = "moves")]
    pub moves: HashMap<String, MoveCategory>,

    /// A dictionary object containing oracle collections, which may contain
    /// oracle tables and/or oracle collections.
    #[serde(rename = "oracles")]
    pub oracles: HashMap<String, OracleCollection>,

    #[serde(rename = "rules")]
    pub rules: Rules,

    /// A dictionary object containing atlas collections, which contain atlas
    /// entries.
    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<HashMap<String, Atlas>>>,

    /// A dictionary object of delve sites, like the premade delve sites
    /// presented in Ironsworn: Delve
    #[serde(rename = "delve_sites")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delveSites: Option<Box<HashMap<String, DelveSite>>>,

    /// A dictionary object containing NPC collections, which contain NPCs.
    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<HashMap<String, NpcCollection>>>,

    /// A dictionary object containing rarities, like those presented in
    /// Ironsworn: Delve.
    #[serde(rename = "rarities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rarities: Option<Box<HashMap<String, Rarity>>>,

    /// A dictionary object containing delve site domains.
    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<HashMap<String, DelveSiteDomain>>>,

    /// A dictionary object containing delve site themes.
    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<HashMap<String, DelveSiteTheme>>>,

    /// A dictionary object of truth categories.
    #[serde(rename = "truths")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truths: Option<Box<HashMap<String, Truth>>>,
}

#[derive(Serialize, Deserialize)]
pub enum ActionRollMethod {
    /// Use **every** roll option at once.
    #[serde(rename = "all")]
    All,

    /// Use the roll option with the best/highest value.
    #[serde(rename = "highest")]
    Highest,

    /// Use the roll option with the worst/lowest value.
    #[serde(rename = "lowest")]
    Lowest,

    /// An automatic miss.
    #[serde(rename = "miss")]
    Miss,

    /// The player chooses which roll option to use.
    #[serde(rename = "player_choice")]
    PlayerChoice,

    /// An automatic strong hit.
    #[serde(rename = "strong_hit")]
    StrongHit,

    /// An automatic weak hit.
    #[serde(rename = "weak_hit")]
    WeakHit,
}

#[derive(Serialize, Deserialize)]
pub struct Asset {
    #[serde(rename = "abilities")]
    pub abilities: Vec<AssetAbility>,

    /// A localized category label for this asset. This is the surtitle above
    /// the asset's name on the card.
    #[serde(rename = "asset_type")]
    pub assetType: Label,

    /// If `true`, this asset counts as an impact (Starforged) or a debility
    /// (classic Ironsworn).
    #[serde(rename = "count_as_impact")]
    pub countAsImpact: bool,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Most assets only benefit to their owner, but certain assets (like
    /// Starforged's module and command vehicle assets) are shared amongst the
    /// player's allies, too.
    #[serde(rename = "shared")]
    pub shared: bool,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Box<AssetAttachment>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this asset.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// Controls are condition meters, clocks, counters, and other asset input
    /// fields whose values are expected to change throughout the life of the
    /// asset.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetControlField>>>,

    /// This asset's icon.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Options are input fields set when the player purchases the asset.
    /// They're likely to remain the same through the life of the asset.
    /// Typically, they are rendered at the top of the asset card.
    #[serde(rename = "options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<Box<HashMap<String, AssetOptionField>>>,

    /// Describes prerequisites for purchasing or using this asset.
    #[serde(rename = "requirement")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requirement: Option<Box<MarkdownString>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

/// An asset ability: one of the purchasable features of an asset. Most assets
/// have three.
#[derive(Serialize, Deserialize)]
pub struct AssetAbility {
    /// Is this asset ability enabled?
    #[serde(rename = "enabled")]
    pub enabled: bool,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetAbilityId,

    /// The complete rules text of this asset ability.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Fields whose values are expected to change over the life of the asset.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetAbilityControlField>>>,

    /// Changes made to the asset, when this ability is enabled.
    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    /// Describes changes made to various moves by this asset ability. Usually
    /// these require specific trigger conditions.
    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,

    /// Unique moves added by this asset ability.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<HashMap<String, Move>>>,

    /// A handful of asset abilities have a label/name, for instance classic
    /// Ironsworn companion assets. Most canonical assets omit this property.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Box<Label>>,

    /// Fields that are expected to be set once and remain the same through the
    /// life of the asset.
    #[serde(rename = "options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<Box<HashMap<String, AssetAbilityOptionField>>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetAbilityControlField {
    #[serde(rename = "checkbox")]
    Checkbox(AssetAbilityControlFieldCheckbox),

    #[serde(rename = "clock")]
    Clock(AssetAbilityControlFieldClock),

    #[serde(rename = "counter")]
    Counter(AssetAbilityControlFieldCounter),
}

/// Represents a checkbox.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldCheckbox {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetAbilityControlFieldId,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,
}

/// A clock with 4, 6, 8, or 10 segments.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldClock {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetAbilityControlFieldId,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The size of the clock -- in other words, the maximum number of filled
    /// clock segments.
    #[serde(rename = "max")]
    pub max: i8,

    /// The minimum number of filled clock segments. This is always 0.
    #[serde(rename = "min")]
    pub min: i8,

    /// The current number of filled clock segments.
    #[serde(rename = "value")]
    pub value: i8,
}

/// A counter that starts at zero, with an optional maximum value.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldCounter {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetAbilityControlFieldId,

    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "max")]
    pub max: i16,

    /// The (inclusive) minimum value.
    #[serde(rename = "min")]
    pub min: i16,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: i16,
}

/// A unique ID for an AssetAbilityControlField.
pub type AssetAbilityControlFieldId = String;

/// A unique ID for an AssetAbility.
pub type AssetAbilityId = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetAbilityOptionField {
    #[serde(rename = "text")]
    Text(AssetAbilityOptionFieldText),
}

/// Represents an input that accepts plain text.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityOptionFieldText {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetAbilityOptionFieldId,

    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "value")]
    pub value: String,
}

/// A unique ID for an AssetAbilityOptionField.
pub type AssetAbilityOptionFieldId = String;

/// Describes which assets can be attached to this asset. Example: Starforged's
/// Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
/// Starforged for more info.
#[derive(Serialize, Deserialize)]
pub struct AssetAttachment {
    /// Asset IDs (which may be wildcards) that may be attached to this asset
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    #[serde(rename = "max")]
    pub max: i16,
}

/// A checkbox control field, rendered as part of an asset condition meter.
#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetConditionMeterControlField {
    #[serde(rename = "card_flip")]
    CardFlip(AssetConditionMeterControlFieldCardFlip),

    #[serde(rename = "checkbox")]
    Checkbox(AssetConditionMeterControlFieldCheckbox),
}

/// When its value is set to `true` it means that the card is flipped over.
/// Some assets use this to represent a 'broken' state (e.g. Starforged Module
/// assets).
#[derive(Serialize, Deserialize)]
pub struct AssetConditionMeterControlFieldCardFlip {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetConditionMeterControlFieldId,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// Is the card flipped over?
    #[serde(rename = "value")]
    pub value: bool,
}

/// Represents a checkbox.
#[derive(Serialize, Deserialize)]
pub struct AssetConditionMeterControlFieldCheckbox {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetConditionMeterControlFieldId,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,
}

/// A unique ID for an AssetConditionMeterControlField.
pub type AssetConditionMeterControlFieldId = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetControlField {
    #[serde(rename = "card_flip")]
    CardFlip(AssetControlFieldCardFlip),

    #[serde(rename = "checkbox")]
    Checkbox(AssetControlFieldCheckbox),

    #[serde(rename = "condition_meter")]
    ConditionMeter(AssetControlFieldConditionMeter),

    #[serde(rename = "select_enhancement")]
    SelectEnhancement(AssetControlFieldSelectEnhancement),
}

/// When its value is set to `true` it means that the card is flipped over.
/// Some assets use this to represent a 'broken' state (e.g. Starforged Module
/// assets).
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldCardFlip {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetControlFieldId,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// Is the card flipped over?
    #[serde(rename = "value")]
    pub value: bool,
}

/// Represents a checkbox.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldCheckbox {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetControlFieldId,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,
}

/// Provides hints for moves that interact with this condition meter, such as
/// suffer and recovery moves.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldConditionMeterMoves {
    /// The ID(s) of recovery moves associated with this meter.
    #[serde(rename = "recover")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recover: Option<Box<Vec<MoveIdWildcard>>>,

    /// The ID(s) of suffer moves associated with the condition meter. If the
    /// suffer move makes an action roll, this condition meter value should be
    /// made available as a roll option.
    #[serde(rename = "suffer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suffer: Option<Box<Vec<MoveIdWildcard>>>,
}

/// Some assets provide a special condition meter of their own. The most common
/// example is the health meters on companion assets. Asset condition meters
/// may also include their own controls, such as the checkboxes that Starforged
/// companion assets use to indicate they are "out of action".
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldConditionMeter {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetControlFieldId,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i8,

    /// The minimum value of this meter.
    #[serde(rename = "min")]
    pub min: i8,

    /// The current value of this meter.
    #[serde(rename = "value")]
    pub value: i8,

    /// Checkbox controls rendered as part of the condition meter.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetConditionMeterControlField>>>,

    /// Provides hints for moves that interact with this condition meter, such
    /// as suffer and recovery moves.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<AssetControlFieldConditionMeterMoves>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "option_type")]
pub enum AssetControlFieldSelectEnhancementChoice {
    #[serde(rename = "option")]
    Option(AssetControlFieldSelectEnhancementChoiceOption),

    #[serde(rename = "option_group")]
    OptionGroup(AssetControlFieldSelectEnhancementChoiceOptionGroup),
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancementChoiceOption {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

#[derive(Serialize, Deserialize)]
pub enum AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType {
    #[serde(rename = "option")]
    Option,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancementChoiceOptionGroupChoice {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "option_type")]
    pub optionType: AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType,

    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

/// Represents a grouping of options in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancementChoiceOptionGroup {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetControlFieldSelectEnhancementChoiceOptionGroupChoice>,

    /// A label for this option group.
    #[serde(rename = "name")]
    pub name: Label,
}

/// Select from player and/or asset enhancements. Use it to describe modal
/// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
/// (Sundered Isles).
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancement {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetControlFieldSelectEnhancementChoice>,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetControlFieldId,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The key of the currently selected choice from the `choices` property, or
    /// `null` if none is selected.
    #[serde(rename = "value")]
    pub value: DictKey,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetControlFieldEnhancement {
    #[serde(rename = "condition_meter")]
    ConditionMeter(AssetControlFieldEnhancementConditionMeter),
}

/// Some assets provide a special condition meter of their own. The most common
/// example is the health meters on companion assets. Asset condition meters
/// may also include their own controls, such as the checkboxes that Starforged
/// companion assets use to indicate they are "out of action".
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldEnhancementConditionMeter {
    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i8,
}

/// A unique ID for an AssetControlField.
pub type AssetControlFieldId = String;

/// A wildcarded ID that can be used to match multiple AssetControlFields.
pub type AssetControlFieldIdWildcard = String;

/// Describes enhancements made to this asset in a partial asset object. The
/// changes should be applied recursively; only the values that are specified
/// should be changed.
#[derive(Serialize, Deserialize)]
pub struct AssetEnhancement {
    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Box<AssetAttachment>>,

    /// Controls are condition meters, clocks, counters, and other asset input
    /// fields whose values are expected to change throughout the life of the
    /// asset.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetControlFieldEnhancement>>>,

    /// If `true`, this asset counts as an impact (Starforged) or a debility
    /// (classic Ironsworn).
    #[serde(rename = "count_as_impact")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countAsImpact: Option<Box<bool>>,

    /// Most assets only benefit to their owner, but certain assets (like
    /// Starforged's module and command vehicle assets) are shared amongst the
    /// player's allies, too.
    #[serde(rename = "shared")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared: Option<Box<bool>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

/// A unique ID for an Asset.
pub type AssetId = String;

/// A wildcarded ID that can be used to match multiple Assets.
pub type AssetIdWildcard = String;

/// Options are asset input fields which are set once, usually when the
/// character takes the asset. The most common example is the "name" field on
/// companion assets. A more complex example is the choice of a god's stat for
/// the Devotant asset.
#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetOptionField {
    #[serde(rename = "select_enhancement")]
    SelectEnhancement(AssetOptionFieldSelectEnhancement),

    #[serde(rename = "select_value")]
    SelectValue(AssetOptionFieldSelectValue),

    #[serde(rename = "text")]
    Text(AssetOptionFieldText),
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "option_type")]
pub enum AssetOptionFieldSelectEnhancementChoice {
    #[serde(rename = "option")]
    Option(AssetOptionFieldSelectEnhancementChoiceOption),

    #[serde(rename = "option_group")]
    OptionGroup(AssetOptionFieldSelectEnhancementChoiceOptionGroup),
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancementChoiceOption {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

#[derive(Serialize, Deserialize)]
pub enum AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType {
    #[serde(rename = "option")]
    Option,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "option_type")]
    pub optionType: AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType,

    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

/// Represents a grouping of options in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancementChoiceOptionGroup {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice>,

    /// A label for this option group.
    #[serde(rename = "name")]
    pub name: Label,
}

/// Select from player and/or asset enhancements. Use it to describe modal
/// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
/// (Sundered Isles).
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancement {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetOptionFieldSelectEnhancementChoice>,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetOptionFieldId,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The key of the currently selected choice from the `choices` property, or
    /// `null` if none is selected.
    #[serde(rename = "value")]
    pub value: DictKey,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "using")]
pub enum AssetOptionFieldSelectValueChoice {
    #[serde(rename = "asset_control")]
    AssetControl(AssetOptionFieldSelectValueChoiceAssetControl),

    #[serde(rename = "asset_option")]
    AssetOption(AssetOptionFieldSelectValueChoiceAssetOption),

    #[serde(rename = "attached_asset_control")]
    AttachedAssetControl(AssetOptionFieldSelectValueChoiceAttachedAssetControl),

    #[serde(rename = "attached_asset_option")]
    AttachedAssetOption(AssetOptionFieldSelectValueChoiceAttachedAssetOption),

    #[serde(rename = "condition_meter")]
    ConditionMeter(AssetOptionFieldSelectValueChoiceConditionMeter),

    #[serde(rename = "custom")]
    Custom(AssetOptionFieldSelectValueChoiceCustom),

    #[serde(rename = "stat")]
    Stat(AssetOptionFieldSelectValueChoiceStat),
}

#[derive(Serialize, Deserialize)]
pub enum AssetOptionFieldSelectValueChoiceAssetControlOptionType {
    #[serde(rename = "option")]
    Option,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectValueChoiceAssetControl {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,

    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "option_type")]
    pub optionType: AssetOptionFieldSelectValueChoiceAssetControlOptionType,
}

#[derive(Serialize, Deserialize)]
pub enum AssetOptionFieldSelectValueChoiceAssetOptionOptionType {
    #[serde(rename = "option")]
    Option,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectValueChoiceAssetOption {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,

    #[serde(rename = "option_type")]
    pub optionType: AssetOptionFieldSelectValueChoiceAssetOptionOptionType,
}

#[derive(Serialize, Deserialize)]
pub enum AssetOptionFieldSelectValueChoiceAttachedAssetControlOptionType {
    #[serde(rename = "option")]
    Option,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectValueChoiceAttachedAssetControl {
    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,

    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "option_type")]
    pub optionType: AssetOptionFieldSelectValueChoiceAttachedAssetControlOptionType,
}

#[derive(Serialize, Deserialize)]
pub enum AssetOptionFieldSelectValueChoiceAttachedAssetOptionOptionType {
    #[serde(rename = "option")]
    Option,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectValueChoiceAttachedAssetOption {
    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,

    #[serde(rename = "option_type")]
    pub optionType: AssetOptionFieldSelectValueChoiceAttachedAssetOptionOptionType,
}

#[derive(Serialize, Deserialize)]
pub enum AssetOptionFieldSelectValueChoiceConditionMeterOptionType {
    #[serde(rename = "option")]
    Option,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectValueChoiceConditionMeter {
    #[serde(rename = "condition_meter")]
    pub conditionMeter: ConditionMeterKey,

    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "option_type")]
    pub optionType: AssetOptionFieldSelectValueChoiceConditionMeterOptionType,
}

#[derive(Serialize, Deserialize)]
pub enum AssetOptionFieldSelectValueChoiceCustomOptionType {
    #[serde(rename = "option")]
    Option,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectValueChoiceCustom {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "option_type")]
    pub optionType: AssetOptionFieldSelectValueChoiceCustomOptionType,

    #[serde(rename = "value")]
    pub value: i16,
}

#[derive(Serialize, Deserialize)]
pub enum AssetOptionFieldSelectValueChoiceStatOptionType {
    #[serde(rename = "option")]
    Option,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectValueChoiceStat {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "option_type")]
    pub optionType: AssetOptionFieldSelectValueChoiceStatOptionType,

    #[serde(rename = "stat")]
    pub stat: StatKey,
}

/// Represents a list of mutually exclusive choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectValue {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetOptionFieldSelectValueChoice>,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetOptionFieldId,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The key of the currently selected choice from the `choices` property, or
    /// `null` if none is selected.
    #[serde(rename = "value")]
    pub value: DictKey,
}

/// Represents an input that accepts plain text.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldText {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetOptionFieldId,

    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "value")]
    pub value: String,
}

/// A unique ID for an AssetOptionField.
pub type AssetOptionFieldId = String;

/// A wildcarded ID that can be used to match multiple AssetOptionFields.
pub type AssetOptionFieldIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub struct AssetType {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AssetTypeId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, Asset>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<AssetTypeId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<AssetTypeId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

/// A unique ID for an AssetType.
pub type AssetTypeId = String;

#[derive(Serialize, Deserialize)]
pub struct Atlas {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AtlasId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "collections")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collections: Option<Box<HashMap<String, Atlas>>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, AtlasEntry>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<AtlasId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<AtlasId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

/// An atlas entry, like the Ironlands region entries found in classic
/// Ironsworn.
#[derive(Serialize, Deserialize)]
pub struct AtlasEntry {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "features")]
    pub features: Vec<MarkdownString>,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: AtlasEntryId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "quest_starter")]
    pub questStarter: MarkdownString,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "your_truth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub yourTruth: Option<Box<MarkdownString>>,
}

/// A unique ID for an AtlasEntry.
pub type AtlasEntryId = String;

/// A wildcarded ID that can be used to match multiple AtlasEntrys.
pub type AtlasEntryIdWildcard = String;

/// A unique ID for an Atlas.
pub type AtlasId = String;

/// A wildcarded ID that can be used to match multiple Atlass.
pub type AtlasIdWildcard = String;

/// Challenge rank, represented as an integer from 1 (troublesome) to 5 (epic).
pub type ChallengeRank = u8;

/// A basic, rollable player character resource specified by the ruleset.
pub type ConditionMeterKey = DictKey;

/// Describes a standard player character condition meter.
#[derive(Serialize, Deserialize)]
pub struct ConditionMeterRule {
    /// A description of this condition meter.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i8,

    /// The minimum value of this meter.
    #[serde(rename = "min")]
    pub min: i8,

    /// Is this condition meter shared by all players?
    #[serde(rename = "shared")]
    pub shared: bool,

    /// The current value of this meter.
    #[serde(rename = "value")]
    pub value: i8,
}

/// A unique ID for a ConditionMeterRule.
pub type ConditionMeterRuleId = String;

/// A CSS color value. See: https://developer.mozilla.org/en-
/// US/docs/Web/CSS/color_value
pub type CssColor = String;

/// A delve site with a theme, domain, and denizens.
#[derive(Serialize, Deserialize)]
pub struct DelveSite {
    #[serde(rename = "denizens")]
    pub denizens: Vec<DelveSiteDenizen>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "domain")]
    pub domain: DelveSiteDomainId,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: DelveSiteId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "theme")]
    pub theme: DelveSiteThemeId,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// An additional theme or domain card ID, for use with optional rules in
    /// Ironsworn: Delve.
    #[serde(rename = "extra_card")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extraCard: Option<Box<String>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// The ID of an atlas entry representing the region in which this delve
    /// site is located.
    #[serde(rename = "region")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub region: Option<Box<AtlasEntryId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct DelveSiteDenizen {
    #[serde(rename = "frequency")]
    pub frequency: DelveSiteDenizenFrequency,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: DelveSiteDenizenId,

    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Box<Label>>,

    /// The ID of the relevant NPC entry, if one is specified.
    #[serde(rename = "npc")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npc: Option<Box<NpcId>>,
}

#[derive(Serialize, Deserialize)]
pub enum DelveSiteDenizenFrequency {
    #[serde(rename = "common")]
    Common,

    #[serde(rename = "rare")]
    Rare,

    #[serde(rename = "uncommon")]
    Uncommon,

    #[serde(rename = "unforeseen")]
    Unforeseen,

    #[serde(rename = "very_common")]
    VeryCommon,
}

/// A unique ID for a DelveSiteDenizen.
pub type DelveSiteDenizenId = String;

/// A delve site Domain card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomain {
    #[serde(rename = "dangers")]
    pub dangers: Vec<DelveSiteDomainDangerRow>,

    #[serde(rename = "features")]
    pub features: Vec<DelveSiteDomainFeatureRow>,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: DelveSiteDomainId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "summary")]
    pub summary: MarkdownString,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// An oracle table ID containing place name elements. For examples, see
    /// oracle ID `delve/oracles/site_name/place/barrow`, and its siblings in
    /// oracle collection ID `delve/collections/oracles/site_name/place`. These
    /// oracles are used by the site name oracle from Ironsworn: Delve (ID:
    /// delve/oracles/site_name/format) to create random names for delve sites.
    #[serde(rename = "name_oracle")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nameOracle: Option<Box<OracleTableId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

/// Represents a single Danger entry from a delve site Domain card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomainDangerRow {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: DomainDangerRowId,

    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "result")]
    pub result: MarkdownString,

    /// Optional tertiary text content for this row. Generally, this is longer
    /// than both `result` and `summary`.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleTableId>>,

    #[serde(rename = "i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// Optional secondary text content for this row. Generally, this is longer
    /// than `result`.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// Represents a single Feature entry from a delve site Domain card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomainFeatureRow {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: DomainFeatureRowId,

    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "result")]
    pub result: MarkdownString,

    /// Optional tertiary text content for this row. Generally, this is longer
    /// than both `result` and `summary`.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleTableId>>,

    #[serde(rename = "i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// Optional secondary text content for this row. Generally, this is longer
    /// than `result`.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// A unique ID for a DelveSiteDomain.
pub type DelveSiteDomainId = String;

/// A unique ID for a DelveSite.
pub type DelveSiteId = String;

/// A delve site theme card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteTheme {
    #[serde(rename = "dangers")]
    pub dangers: Vec<DelveSiteThemeDangerRow>,

    #[serde(rename = "features")]
    pub features: Vec<DelveSiteThemeFeatureRow>,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: DelveSiteThemeId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "summary")]
    pub summary: MarkdownString,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

/// Represents a single Danger entry from a delve site Theme card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteThemeDangerRow {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: ThemeDangerRowId,

    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "result")]
    pub result: MarkdownString,

    /// Optional tertiary text content for this row. Generally, this is longer
    /// than both `result` and `summary`.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleTableId>>,

    #[serde(rename = "i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// Optional secondary text content for this row. Generally, this is longer
    /// than `result`.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// Represents a single Feature entry from a delve site Theme card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteThemeFeatureRow {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: ThemeFeatureRowId,

    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "result")]
    pub result: MarkdownString,

    /// Optional tertiary text content for this row. Generally, this is longer
    /// than both `result` and `summary`.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleTableId>>,

    #[serde(rename = "i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// Optional secondary text content for this row. Generally, this is longer
    /// than `result`.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// A unique ID for a DelveSiteTheme.
pub type DelveSiteThemeId = String;

/// A simple dice roll expression with an optional modifer.
pub type DiceExpression = String;

/// A key used in a Datasworn dictionary object.
pub type DictKey = String;

/// A unique ID for a DomainDangerRow.
pub type DomainDangerRowId = String;

/// A unique ID for a DomainFeatureRow.
pub type DomainFeatureRowId = String;

/// The ID of a Datasworn package that relies on an external package to provide
/// its ruleset.
pub type ExpansionId = String;

#[derive(Serialize, Deserialize)]
pub struct I18nHint {
    #[serde(rename = "part_of_speech")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partOfSpeech: Option<Box<PartOfSpeech>>,
}

#[derive(Serialize, Deserialize)]
pub struct I18nHintsTemplate {
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<I18nHint>>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<Box<I18nHint>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<I18nHint>>,
}

/// Internationalization/localization hints for the text content of this object.
#[derive(Serialize, Deserialize)]
pub struct I18nHints {
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<I18nHint>>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<Box<I18nHint>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<I18nHint>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<I18nHintsTemplate>>,
}

/// Describes a category of standard impacts/debilities.
#[derive(Serialize, Deserialize)]
pub struct ImpactCategory {
    /// A dictionary object of the Impacts in this category.
    #[serde(rename = "contents")]
    pub contents: HashMap<String, ImpactRule>,

    /// A description of this impact category.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// A label for this impact category.
    #[serde(rename = "label")]
    pub label: Label,
}

/// Describes a standard impact/debility.
#[derive(Serialize, Deserialize)]
pub struct ImpactRule {
    /// A description of this impact.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// The label for this impact.
    #[serde(rename = "label")]
    pub label: Label,

    /// Is this impact permanent?
    #[serde(rename = "permanent")]
    pub permanent: bool,

    /// Any ruleset condition meters that can't recover when this impact is
    /// active.
    #[serde(rename = "prevents_recovery")]
    pub preventsRecovery: Vec<ConditionMeterKey>,

    /// Is this impact applied to all players at once?
    #[serde(rename = "shared")]
    pub shared: bool,
}

/// A unique ID for an ImpactRuleCollection.
pub type ImpactRuleCollectionId = String;

/// A unique ID for an ImpactRule.
pub type ImpactRuleId = String;

/// A localized label for an input. In some contexts it may be undesirable to
/// render this text, but it should always be exposed to assistive technology
/// (e.g. with `aria-label` in HTML).
pub type InputLabel = String;

/// A localized plain text name or label.
pub type Label = String;

/// Localized text, formatted in Markdown.
/// 
/// It uses some custom syntax; e.g. `{{table:some_oracle_table_id}}` indicates
/// that the referenced oracle table is rendered there part of the source
/// material.
pub type MarkdownString = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "roll_type")]
pub enum Move {
    #[serde(rename = "action_roll")]
    ActionRoll(MoveActionRoll),

    #[serde(rename = "no_roll")]
    NoRoll(MoveNoRoll),

    #[serde(rename = "progress_roll")]
    ProgressRoll(MoveProgressRoll),

    #[serde(rename = "special_track")]
    SpecialTrack(MoveSpecialTrack),
}

/// A move that makes an action roll.
#[derive(Serialize, Deserialize)]
pub struct MoveActionRoll {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: MoveId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerActionRoll,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// Oracles associated with this move. It's not recommended to roll these
    /// automatically, as almost all moves present them as an option, not
    /// a requirement.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleTableId>>>,

    /// Indicates that this move replaces the identified move. References to the
    /// replaced move can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

/// A move that makes no progress rolls or action rolls.
#[derive(Serialize, Deserialize)]
pub struct MoveNoRoll {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: MoveId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerNoRoll,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// Oracles associated with this move. It's not recommended to roll these
    /// automatically, as almost all moves present them as an option, not
    /// a requirement.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleTableId>>>,

    /// Indicates that this move replaces the identified move. References to the
    /// replaced move can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

/// A progress move that rolls on a standard progress track type (whose features
/// are defined by this move object). For progress rolls that use special
/// tracks, see MoveSpecialTrack.
#[derive(Serialize, Deserialize)]
pub struct MoveProgressRoll {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: MoveId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Describes the common features of progress tracks associated with this
    /// move.
    #[serde(rename = "tracks")]
    pub tracks: ProgressTrackTypeInfo,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerProgressRoll,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// Oracles associated with this move. It's not recommended to roll these
    /// automatically, as almost all moves present them as an option, not
    /// a requirement.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleTableId>>>,

    /// Indicates that this move replaces the identified move. References to the
    /// replaced move can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

/// A progress move that rolls on a special track, such as Legacies (Starforged)
/// or Bonds (classic Ironsworn). For progress moves that use standard progress
/// tracks, see MoveProgressRoll instead.
#[derive(Serialize, Deserialize)]
pub struct MoveSpecialTrack {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: MoveId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerSpecialTrack,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// Oracles associated with this move. It's not recommended to roll these
    /// automatically, as almost all moves present them as an option, not
    /// a requirement.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleTableId>>>,

    /// Indicates that this move replaces the identified move. References to the
    /// replaced move can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveCategory {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: MoveCategoryId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, Move>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<MoveCategoryId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveCategoryId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

/// A unique ID for a MoveCategory.
pub type MoveCategoryId = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "roll_type")]
pub enum MoveEnhancement {
    #[serde(rename = "action_roll")]
    ActionRoll(MoveEnhancementActionRoll),

    #[serde(rename = "no_roll")]
    NoRoll(MoveEnhancementNoRoll),

    #[serde(rename = "progress_roll")]
    ProgressRoll(MoveEnhancementProgressRoll),

    #[serde(rename = "special_track")]
    SpecialTrack(MoveEnhancementSpecialTrack),
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementActionRoll {
    #[serde(rename = "enhances")]
    pub enhances: Vec<MoveIdWildcard>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerActionRollEnhancement>>,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementNoRoll {
    #[serde(rename = "enhances")]
    pub enhances: Vec<MoveIdWildcard>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerNoRollEnhancement>>,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementProgressRoll {
    #[serde(rename = "enhances")]
    pub enhances: Vec<MoveIdWildcard>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerProgressRollEnhancement>>,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementSpecialTrack {
    #[serde(rename = "enhances")]
    pub enhances: Vec<MoveIdWildcard>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerSpecialTrackEnhancement>>,
}

/// A move ID, for a standard move or a unique asset move
pub type MoveId = String;

/// A move ID with wildcards.
pub type MoveIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub struct MoveOutcome {
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub enum MoveOutcomeType {
    /// The score doesn't beat either challenge die.
    #[serde(rename = "miss")]
    Miss,

    /// The score is greater than both challenge dice.
    #[serde(rename = "strong_hit")]
    StrongHit,

    /// The score is greater than one challenge die.
    #[serde(rename = "weak_hit")]
    WeakHit,
}

/// A standalone localized description for each move outcome (miss, weak hit,
/// or strong hit). This is for for e.g. VTT implementations, where it's often
/// useful to display only the rules text relevant to a roll result.
/// 
///   This often requires light editorialization to create text that can stand
/// alone without reference to the rest of the move. For example, 'as above'
/// (in reference to another move outcome) shouldn't be used here; instead, the
/// relevant text should be repeated.
#[derive(Serialize, Deserialize)]
pub struct MoveOutcomes {
    #[serde(rename = "miss")]
    pub miss: MoveOutcome,

    #[serde(rename = "strong_hit")]
    pub strongHit: MoveOutcome,

    #[serde(rename = "weak_hit")]
    pub weakHit: MoveOutcome,
}

#[derive(Serialize, Deserialize)]
pub enum MoveRollType {
    /// A move that makes an action roll.
    #[serde(rename = "action_roll")]
    ActionRoll,

    /// A move that makes no action rolls or progress rolls.
    #[serde(rename = "no_roll")]
    NoRoll,

    /// A progress move that rolls on a standard progress track type (defined by
    /// this move).
    #[serde(rename = "progress_roll")]
    ProgressRoll,

    /// A progress move that rolls on one or more special tracks, like Bonds
    /// (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    #[serde(rename = "special_track")]
    SpecialTrack,
}

/// A non-player character entry, similar to those in Chapter 5 of the Ironsworn
/// Rulebook, or Chapter 4 of Starforged.
#[derive(Serialize, Deserialize)]
pub struct Npc {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "drives")]
    pub drives: Vec<MarkdownString>,

    #[serde(rename = "features")]
    pub features: Vec<MarkdownString>,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: NpcId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "nature")]
    pub nature: NpcNature,

    #[serde(rename = "quest_starter")]
    pub questStarter: MarkdownString,

    /// The suggested challenge rank for this NPC.
    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "tactics")]
    pub tactics: Vec<MarkdownString>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "variants")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variants: Option<Box<HashMap<String, NpcVariant>>>,

    #[serde(rename = "your_truth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub yourTruth: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct NpcCollection {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: NpcCollectionId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, Npc>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<NpcCollectionId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<NpcCollectionId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

/// A unique ID for a NpcCollection.
pub type NpcCollectionId = String;

/// A unique ID for a Npc.
pub type NpcId = String;

/// A wildcarded ID that can be used to match multiple Npcs.
pub type NpcIdWildcard = String;

/// A localized category label describing the nature of this NPC.
/// 
/// In Ironsworn classic, this is probably the singular form of the parent
/// collection's name.
/// 
/// For Starforged, see the table on p. 258 for examples.
pub type NpcNature = Label;

#[derive(Serialize, Deserialize)]
pub struct NpcVariant {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: NpcVariantId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "nature")]
    pub nature: NpcNature,

    /// The suggested challenge rank for this NPC.
    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

/// A unique ID for a NpcVariant.
pub type NpcVariantId = String;

#[derive(Serialize, Deserialize)]
pub struct OracleCollection {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: OracleCollectionId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "collections")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collections: Option<Box<HashMap<String, OracleCollection>>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, OracleTable>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<OracleCollectionId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    #[serde(rename = "rendering")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rendering: Option<Box<OracleCollectionRendering>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleCollectionId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

/// A unique ID for an OracleCollection.
pub type OracleCollectionId = String;

/// Describes the presentation of this oracle collection, which might represent
/// a group of separate tables, or a single table with additional columns.
#[derive(Serialize, Deserialize)]
#[serde(tag = "style")]
pub enum OracleCollectionRendering {
    #[serde(rename = "multi_table")]
    MultiTable(OracleCollectionRenderingMultiTable),

    #[serde(rename = "tables")]
    Tables(OracleCollectionRenderingTables),
}

#[derive(Serialize, Deserialize)]
pub struct OracleCollectionRenderingMultiTable {
    #[serde(rename = "columns")]
    pub columns: HashMap<String, OracleCollectionTableColumn>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleCollectionRenderingTables {}

#[derive(Serialize, Deserialize)]
pub enum OracleCollectionStyle {
    /// Presented as a single table, with its OracleTable children rendered
    /// as columns.
    #[serde(rename = "multi_table")]
    MultiTable,

    /// Presented as a collection of separate tables.
    #[serde(rename = "tables")]
    Tables,
}

#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableColumn {
    #[serde(rename = "content_type")]
    pub contentType: OracleTableColumnContentKey,

    /// The column's header text.
    #[serde(rename = "label")]
    pub label: Label,

    /// The key of the OracleTable (within this collection), whose data is used
    /// to render this column.
    #[serde(rename = "table_key")]
    pub tableKey: DictKey,

    /// The thematic color for this column.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,
}

/// Provides string templates that may be used in place of the static
/// row text from `OracleTableRow#result`, `OracleTableRow#summary`, and
/// `OracleTableRow#description`.
/// 
///   These strings are formatted in Markdown, but use a special syntax
/// for their placeholders: `{{result:some_oracle_table_id}}`. The
/// placeholder should be replaced with the value of a rolled (or selected)
/// `OracleTableRow#result` from the target oracle table ID.
#[derive(Serialize, Deserialize)]
pub struct OracleRollTemplate {
    /// A string template that may be used in place of
    /// OracleTableRow#description.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<TemplateString>>,

    /// A string template that may be used in place of OracleTableRow#result.
    #[serde(rename = "result")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<Box<TemplateString>>,

    /// A string template that may be used in place of OracleTableRow#summary.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<TemplateString>>,
}

/// Represents a single oracle table, or a single table column of a table that
/// has multiple "Roll" or "Result" columns.
#[derive(Serialize, Deserialize)]
pub struct OracleTable {
    /// The roll used to select a result on this table.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: OracleTableId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "table")]
    pub table: Vec<OracleTableRow>,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A longer description of the oracle table's intended usage, which might
    /// include multiple paragraphs. If it's only a couple sentences, use the
    /// `summary` key instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// An icon that represents this table.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleTableMatchBehavior>>,

    /// Describes how how to render this table, when presenting it as a
    /// standalone table.
    #[serde(rename = "rendering")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rendering: Option<Box<OracleTableRendering>>,

    /// Indicates that this table replaces the identified table. References to
    /// the replaced table can be considered equivalent to this table.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleTableId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of the oracle table's intended usage, no more than a few
    /// sentences in length. This is intended for use in application tooltips
    /// and similar sorts of hints. Longer text should use the "description"
    /// key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableColumn {
    #[serde(rename = "content_type")]
    pub contentType: OracleTableColumnContentKey,

    /// The column's header text.
    #[serde(rename = "label")]
    pub label: Label,

    /// The thematic color for this column.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,
}

/// The value(s) from each OracleTableRow that is rendered in this column.
#[derive(Serialize, Deserialize)]
pub enum OracleTableColumnContentKey {
    /// Column displays the OracleTableRow's `description` key.
    #[serde(rename = "description")]
    Description,

    /// Column displays the OracleTableRow's `result` key.
    #[serde(rename = "result")]
    Result,

    /// Column displays the roll range (`min` and `max`) of each OracleTableRow.
    #[serde(rename = "roll")]
    Roll,

    /// Column displays the OracleTableRow's `summary` key.
    #[serde(rename = "summary")]
    Summary,
}

/// A unique ID for an OracleTable.
pub type OracleTableId = String;

/// Oracle table wildcards can also use '**' to represent any number of
/// collection levels in the oracle tree.
pub type OracleTableIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub struct OracleTableMatchBehavior {
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

/// Describes the presentation of this table.
#[derive(Serialize, Deserialize)]
#[serde(tag = "style")]
pub enum OracleTableRendering {
    #[serde(rename = "column")]
    Column(OracleTableRenderingColumn),

    #[serde(rename = "embed_in_row")]
    EmbedInRow(OracleTableRenderingEmbedInRow),

    #[serde(rename = "standalone")]
    Standalone(OracleTableRenderingStandalone),
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRenderingColumn {}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRenderingEmbedInRow {}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRenderingStandalone {
    #[serde(rename = "columns")]
    pub columns: HashMap<String, OracleTableColumn>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRoll {
    /// Both Ironsworn and Starforged explicitly recommend *against* rolling
    /// all details at once. That said, some oracle results only provide useful
    /// information once a secondary roll occurs, such as "Action + Theme".
    #[serde(rename = "auto")]
    pub auto: bool,

    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// Special rules on how the oracle table roll is performed.
    #[serde(rename = "method")]
    pub method: OracleTableRollMethod,

    #[serde(rename = "oracle")]
    pub oracle: OracleTableId,

    /// The number of times to roll.
    #[serde(rename = "times")]
    pub times: i16,
}

/// Special roll instructions to use when rolling multiple times on a single
/// oracle table.
#[derive(Serialize, Deserialize)]
pub enum OracleTableRollMethod {
    /// Duplicates should be kept.
    #[serde(rename = "keep_duplicates")]
    KeepDuplicates,

    /// Duplicates should be kept, and they compound to make things worse.
    #[serde(rename = "make_it_worse")]
    MakeItWorse,

    /// Duplicates should be re-rolled.
    #[serde(rename = "no_duplicates")]
    NoDuplicates,
}

/// Represents a row in an oracle table.
#[derive(Serialize, Deserialize)]
pub struct OracleTableRow {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: OracleTableRowId,

    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "result")]
    pub result: MarkdownString,

    /// Optional tertiary text content for this row. Generally, this is longer
    /// than both `result` and `summary`.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleTableId>>,

    #[serde(rename = "i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// Optional secondary text content for this row. Generally, this is longer
    /// than `result`.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// Normally, rows will end with two numbers separated by a dash, indicating
/// their dice range.
/// 
/// Rows with a single number represent unrollable rows that are sometimes
/// included for rendering purposes; in this case, the number represents the
/// row's index.
pub type OracleTableRowId = String;

#[derive(Serialize, Deserialize)]
pub enum OracleTableStyle {
    /// Render as a single column of a table.
    #[serde(rename = "column")]
    Column,

    /// Render as a table, within a row in another table.
    #[serde(rename = "embed_in_row")]
    EmbedInRow,

    /// Render as a standalone table.
    #[serde(rename = "standalone")]
    Standalone,
}

#[derive(Serialize, Deserialize)]
pub enum PartOfSpeech {
    /// An adjective.
    #[serde(rename = "adjective")]
    Adjective,

    /// A common noun used as an adjective, to modify another noun.
    #[serde(rename = "adjunct_common_noun")]
    AdjunctCommonNoun,

    /// A proper noun used as an adjective, to modify another noun.
    #[serde(rename = "adjunct_proper_noun")]
    AdjunctProperNoun,

    /// A verb used as an adjective, to modify a noun.
    #[serde(rename = "attributive_verb")]
    AttributiveVerb,

    /// A common noun.
    #[serde(rename = "common_noun")]
    CommonNoun,

    /// Gerund or present participle of a verb, e.g. "going", "seeing", "waving"
    #[serde(rename = "gerund")]
    Gerund,

    /// A proper noun.
    #[serde(rename = "proper_noun")]
    ProperNoun,

    /// A verb in present tense
    #[serde(rename = "verb")]
    Verb,
}

#[derive(Serialize, Deserialize)]
pub enum ProgressRollMethod {
    /// An automatic miss.
    #[serde(rename = "miss")]
    Miss,

    /// Make a progress roll on a progress track associated with this move.
    #[serde(rename = "progress_roll")]
    ProgressRoll,

    /// An automatic strong hit.
    #[serde(rename = "strong_hit")]
    StrongHit,

    /// An automatic weak hit.
    #[serde(rename = "weak_hit")]
    WeakHit,
}

#[derive(Serialize, Deserialize)]
pub enum ProgressRollOptionUsing {
    #[serde(rename = "progress_track")]
    ProgressTrack,
}

#[derive(Serialize, Deserialize)]
pub struct ProgressRollOption {
    #[serde(rename = "using")]
    pub using: ProgressRollOptionUsing,
}

/// Describes the features of a type of progress track.
#[derive(Serialize, Deserialize)]
pub struct ProgressTrackTypeInfo {
    /// A category label for progress tracks of this type.
    #[serde(rename = "category")]
    pub category: Label,

    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, Option<Value>>>>,
}

/// A rarity, as described in Ironsworn: Delve.
#[derive(Serialize, Deserialize)]
pub struct Rarity {
    /// The asset augmented by this rarity.
    #[serde(rename = "asset")]
    pub asset: AssetId,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: RarityId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    /// From Ironsworn: Delve, p. 174:
    /// 
    ///       Some assets will bring a rarity into play more often than others,
    /// so the experience point cost for a rarity will vary by the linked asset.
    /// These costs are shown in the tables on page 175.
    /// 
    ///       If you are playing solo, and arent concerned with the relative
    /// balance of rarity abilities, you can ignore these variable costs. If so,
    /// spend 3 experience points to purchase a rarity.
    #[serde(rename = "xp_cost")]
    pub xpCost: i16,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

/// A unique ID for a Rarity.
pub type RarityId = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "using")]
pub enum RollableValue {
    #[serde(rename = "asset_control")]
    AssetControl(RollableValueAssetControl),

    #[serde(rename = "asset_option")]
    AssetOption(RollableValueAssetOption),

    #[serde(rename = "attached_asset_control")]
    AttachedAssetControl(RollableValueAttachedAssetControl),

    #[serde(rename = "attached_asset_option")]
    AttachedAssetOption(RollableValueAttachedAssetOption),

    #[serde(rename = "condition_meter")]
    ConditionMeter(RollableValueConditionMeter),

    #[serde(rename = "custom")]
    Custom(RollableValueCustom),

    #[serde(rename = "stat")]
    Stat(RollableValueStat),
}

/// A reference to the value of an asset control.
#[derive(Serialize, Deserialize)]
pub struct RollableValueAssetControl {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,
}

/// A reference to the value of an asset option.
#[derive(Serialize, Deserialize)]
pub struct RollableValueAssetOption {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,
}

/// A reference to the value of an attached asset control. For example, a Module
/// asset could use this to roll using the `integrity` control of an attached
/// Vehicle.
#[derive(Serialize, Deserialize)]
pub struct RollableValueAttachedAssetControl {
    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,
}

/// A reference to the value of an attached asset option.
#[derive(Serialize, Deserialize)]
pub struct RollableValueAttachedAssetOption {
    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,
}

/// A reference to the value of a standard player condition meter.
#[derive(Serialize, Deserialize)]
pub struct RollableValueConditionMeter {
    #[serde(rename = "condition_meter")]
    pub conditionMeter: ConditionMeterKey,
}

/// An arbitrary static integer value with a label.
#[derive(Serialize, Deserialize)]
pub struct RollableValueCustom {
    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: i16,
}

/// A reference to the value of a standard player character stat.
#[derive(Serialize, Deserialize)]
pub struct RollableValueStat {
    #[serde(rename = "stat")]
    pub stat: StatKey,
}

#[derive(Serialize, Deserialize)]
pub enum RollableValueType {
    /// A reference to the value of an asset control.
    #[serde(rename = "asset_control")]
    AssetControl,

    /// A reference to the value of an asset option.
    #[serde(rename = "asset_option")]
    AssetOption,

    /// A reference to the value of an attached asset control. For example, a
    /// Module asset could use this to roll using the `integrity` control of an
    /// attached Vehicle.
    #[serde(rename = "attached_asset_control")]
    AttachedAssetControl,

    /// A reference to the value of an attached asset option.
    #[serde(rename = "attached_asset_option")]
    AttachedAssetOption,

    /// A reference to the value of a standard player condition meter.
    #[serde(rename = "condition_meter")]
    ConditionMeter,

    /// An arbitrary static integer value with a label.
    #[serde(rename = "custom")]
    Custom,

    /// A reference to the value of a standard player character stat.
    #[serde(rename = "stat")]
    Stat,
}

/// Describes rules for player characters in this ruleset, such as stats and
/// condition meters.
#[derive(Serialize, Deserialize)]
pub struct Rules {
    /// Describes the standard condition meters used by player characters in
    /// this ruleset.
    #[serde(rename = "condition_meters")]
    pub conditionMeters: HashMap<String, ConditionMeterRule>,

    /// Describes the standard impacts/debilities used by player characters in
    /// this ruleset.
    #[serde(rename = "impacts")]
    pub impacts: HashMap<String, ImpactCategory>,

    /// Describes the special tracks used by player characters in this
    /// ruleset, like Bonds (classic Ironsworn), Failure (Delve), or Legacies
    /// (Starforged).
    #[serde(rename = "special_tracks")]
    pub specialTracks: HashMap<String, SpecialTrackRule>,

    /// Describes the standard stats used by player characters in this ruleset.
    #[serde(rename = "stats")]
    pub stats: HashMap<String, StatRule>,
}

/// Describes rules for player characters in this ruleset, such as stats and
/// condition meters.
#[derive(Serialize, Deserialize)]
pub struct RulesExpansion {
    /// Describes the standard condition meters used by player characters in
    /// this ruleset.
    #[serde(rename = "condition_meters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conditionMeters: Option<Box<HashMap<String, ConditionMeterRule>>>,

    /// Describes the standard impacts/debilities used by player characters in
    /// this ruleset.
    #[serde(rename = "impacts")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub impacts: Option<Box<HashMap<String, ImpactCategory>>>,

    /// Describes the special tracks used by player characters in this
    /// ruleset, like Bonds (classic Ironsworn), Failure (Delve), or Legacies
    /// (Starforged).
    #[serde(rename = "special_tracks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub specialTracks: Option<Box<HashMap<String, SpecialTrackRule>>>,

    /// Describes the standard stats used by player characters in this ruleset.
    #[serde(rename = "stats")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stats: Option<Box<HashMap<String, StatRule>>>,
}

/// The ID of standalone Datasworn package that describes its own ruleset.
pub type RulesetId = String;

pub type SemanticVersion = String;

#[derive(Serialize, Deserialize)]
pub struct SourceAuthor {
    #[serde(rename = "name")]
    pub name: String,

    /// An optional email contact for the author
    #[serde(rename = "email")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<Box<String>>,

    /// An optional URL for the author's website.
    #[serde(rename = "url")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<Box<String>>,
}

/// Metadata describing the original source of this item
#[derive(Serialize, Deserialize)]
pub struct Source {
    #[serde(rename = "authors")]
    pub authors: Vec<SourceAuthor>,

    /// The date of the source documents's last update, formatted YYYY-MM-DD.
    /// Required because it's used to determine whether the data needs updating.
    #[serde(rename = "date")]
    pub date: String,

    #[serde(rename = "license")]
    pub license: String,

    /// The title of the source document.
    #[serde(rename = "title")]
    pub title: String,

    /// An absolute URL where the source document is available.
    #[serde(rename = "url")]
    pub url: String,

    /// The page number where this item is described in full.
    #[serde(rename = "page")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page: Option<Box<i16>>,
}

#[derive(Serialize, Deserialize)]
pub enum SpecialTrackRollMethod {
    /// Use **every** roll option at once.
    #[serde(rename = "all")]
    All,

    /// Use the roll option with the best/highest value.
    #[serde(rename = "highest")]
    Highest,

    /// Use the roll option with the worst/lowest value.
    #[serde(rename = "lowest")]
    Lowest,

    /// An automatic miss.
    #[serde(rename = "miss")]
    Miss,

    /// The player chooses which roll option to use.
    #[serde(rename = "player_choice")]
    PlayerChoice,

    /// An automatic strong hit.
    #[serde(rename = "strong_hit")]
    StrongHit,

    /// An automatic weak hit.
    #[serde(rename = "weak_hit")]
    WeakHit,
}

/// Describes a special track like Bonds (classic Ironsworn), Failure (Delve),
/// or Legacies (Starforged).
#[derive(Serialize, Deserialize)]
pub struct SpecialTrackRule {
    /// A description of this special track.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// A label for this special track.
    #[serde(rename = "label")]
    pub label: Label,

    /// Is this track an optional rule?
    #[serde(rename = "optional")]
    pub optional: bool,

    /// Is this track shared by all players?
    #[serde(rename = "shared")]
    pub shared: bool,
}

/// A unique ID for a SpecialTrackRule.
pub type SpecialTrackRuleId = String;

/// Special, ruleset-specific progress tracks. Usually, one exists per player
/// character, and they persist through the life of the player character.
/// 'Canonical' examples:
///   * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
/// legacy track, use `bonds_legacy` instead.
///   * `failure_track`, described in Ironsworn: Delve
///   * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
/// Ironsworn: Starforged
/// 
pub type SpecialTrackType = DictKey;

/// A basic player character stat.
pub type StatKey = DictKey;

/// Describes a standard player character stat.
#[derive(Serialize, Deserialize)]
pub struct StatRule {
    /// A description of this stat.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// A label for this stat.
    #[serde(rename = "label")]
    pub label: Label,
}

/// A unique ID for a StatRule.
pub type StatRuleId = String;

#[derive(Serialize, Deserialize)]
pub struct Suggestions {
    #[serde(rename = "assets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assets: Option<Box<Vec<AssetId>>>,

    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<Vec<AtlasEntryId>>>,

    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<Vec<MoveId>>>,

    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<Vec<NpcId>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleTableId>>>,

    #[serde(rename = "rarities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rarities: Option<Box<Vec<RarityId>>>,

    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<Vec<DelveSiteDomainId>>>,

    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<Vec<DelveSiteThemeId>>>,
}

/// A relative URL pointing to a vector image in the SVG format.
pub type SvgImageUrl = String;

/// A rich text string in Markdown with replaced values from oracle roll
/// results.
/// 
/// The custom syntax `{{some_row_key:some_oracle_table_id}}` should be replaced
/// by the `some_row_key` string of a rolled oracle table. This is usually the
/// `result` key, for example `{{result:starforged/oracles/core/action}}`
pub type TemplateString = String;

/// A unique ID for a ThemeDangerRow.
pub type ThemeDangerRowId = String;

/// A unique ID for a ThemeFeatureRow.
pub type ThemeFeatureRowId = String;

/// Describes trigger conditions for a move that makes an action roll.
#[derive(Serialize, Deserialize)]
pub struct TriggerActionRoll {
    /// Specific conditions that qualify for this trigger.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerActionRollCondition>,

    /// A markdown string containing the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be described in individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerActionRollCondition {
    #[serde(rename = "method")]
    pub method: ActionRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<RollableValue>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerActionRollConditionEnhancement {
    #[serde(rename = "method")]
    pub method: ActionRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<RollableValue>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// Describes changes/additions made to the enhanced move's trigger conditions.
#[derive(Serialize, Deserialize)]
pub struct TriggerActionRollEnhancement {
    /// Trigger conditions added to the enhanced move.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerActionRollConditionEnhancement>,
}

/// Information on who can trigger this trigger condition. Usually this is just
/// the player, but some asset abilities can trigger from an ally's move.
#[derive(Serialize, Deserialize)]
pub struct TriggerBy {
    /// Can this trigger be activated by one of the player's allies?
    #[serde(rename = "ally")]
    pub ally: bool,

    /// Can this trigger be activated by the player who owns this?
    #[serde(rename = "player")]
    pub player: bool,
}

/// Describes trigger conditions for a move that makes no rolls.
#[derive(Serialize, Deserialize)]
pub struct TriggerNoRoll {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerNoRollCondition>,

    /// A markdown string containing the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be described in individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerNoRollCondition {
    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// Describes changes/additions made to the enhanced move's trigger conditions.
#[derive(Serialize, Deserialize)]
pub struct TriggerNoRollEnhancement {
    /// Trigger conditions added to the enhanced move.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerNoRollCondition>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRoll {
    /// Specific conditions that qualify for this trigger.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerProgressRollCondition>,

    /// A markdown string containing the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be described in individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRollCondition {
    #[serde(rename = "method")]
    pub method: ProgressRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<ProgressRollOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRollConditionEnhancement {
    #[serde(rename = "method")]
    pub method: ProgressRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<ProgressRollOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// Describes changes/additions made to the enhanced move's trigger conditions.
#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRollEnhancement {
    /// Trigger conditions added to the enhanced move.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerProgressRollConditionEnhancement>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrack {
    /// Specific conditions that qualify for this trigger.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerSpecialTrackCondition>,

    /// A markdown string containing the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be described in individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackCondition {
    #[serde(rename = "method")]
    pub method: SpecialTrackRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<TriggerSpecialTrackConditionOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// A progress move that rolls on one or more special tracks, like Bonds
/// (classic Ironsworn), Failure (Delve), or Legacy (Starforged).
#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackConditionEnhancement {
    #[serde(rename = "method")]
    pub method: SpecialTrackRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<TriggerSpecialTrackConditionOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackConditionOption {
    #[serde(rename = "using")]
    pub using: SpecialTrackType,
}

/// Describes changes/additions made to the enhanced move's trigger conditions.
#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackEnhancement {
    /// Trigger conditions added to the enhanced move.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerSpecialTrackConditionEnhancement>,
}

/// A setting truth category.
#[derive(Serialize, Deserialize)]
pub struct Truth {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: TruthId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "options")]
    pub options: Vec<TruthOption>,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "source")]
    pub source: Source,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "your_character")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub yourCharacter: Option<Box<MarkdownString>>,
}

/// A unique ID for a Truth.
pub type TruthId = String;

#[derive(Serialize, Deserialize)]
pub struct TruthOption {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// The unique Datasworn ID for this item.
    #[serde(rename = "id")]
    pub id: TruthOptionId,

    #[serde(rename = "quest_starter")]
    pub questStarter: MarkdownString,

    #[serde(rename = "max")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max: Option<Box<i16>>,

    #[serde(rename = "min")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub min: Option<Box<i16>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<Box<Vec<TruthOptionTableRow>>>,
}

/// A unique ID for a TruthOption.
pub type TruthOptionId = String;

/// Represents a row in an oracle table.
#[derive(Serialize, Deserialize)]
pub struct TruthOptionTableRow {
    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "result")]
    pub result: MarkdownString,

    /// Optional tertiary text content for this row. Generally, this is longer
    /// than both `result` and `summary`.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleTableId>>,

    #[serde(rename = "i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// Optional secondary text content for this row. Generally, this is longer
    /// than `result`.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// A relative URL pointing to a raster image in the WEBP format.
pub type WebpImageUrl = String;
