// Code generated by jtd-codegen for Go v0.2.1. DO NOT EDIT.

package Datasworn

import (
	"encoding/json"
	"fmt"
)

type Dataforged = interface{}

type ActionRollMethod string

const (
	ActionRollMethodAll ActionRollMethod = "all"

	ActionRollMethodHighest ActionRollMethod = "highest"

	ActionRollMethodLowest ActionRollMethod = "lowest"

	ActionRollMethodMiss ActionRollMethod = "miss"

	ActionRollMethodPlayerChoice ActionRollMethod = "player_choice"

	ActionRollMethodStrongHit ActionRollMethod = "strong_hit"

	ActionRollMethodWeakHit ActionRollMethod = "weak_hit"
)

type ActionRollOption struct {
	Using string

	AssetControl ActionRollOptionAssetControl

	AssetOption ActionRollOptionAssetOption

	AttachedAssetControl ActionRollOptionAttachedAssetControl

	AttachedAssetOption ActionRollOptionAttachedAssetOption

	ConditionMeter ActionRollOptionConditionMeter

	Custom ActionRollOptionCustom

	Stat ActionRollOptionStat
}

func (v ActionRollOption) MarshalJSON() ([]byte, error) {
	switch v.Using {
	case "asset_control":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionAssetControl }{ v.Using, v.AssetControl })
	case "asset_option":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionAssetOption }{ v.Using, v.AssetOption })
	case "attached_asset_control":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionAttachedAssetControl }{ v.Using, v.AttachedAssetControl })
	case "attached_asset_option":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionAttachedAssetOption }{ v.Using, v.AttachedAssetOption })
	case "condition_meter":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionConditionMeter }{ v.Using, v.ConditionMeter })
	case "custom":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionCustom }{ v.Using, v.Custom })
	case "stat":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionStat }{ v.Using, v.Stat })
	}

	return nil, fmt.Errorf("bad Using value: %s", v.Using)
}

func (v *ActionRollOption) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"using"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "asset_control":
		err = json.Unmarshal(b, &v.AssetControl)
	case "asset_option":
		err = json.Unmarshal(b, &v.AssetOption)
	case "attached_asset_control":
		err = json.Unmarshal(b, &v.AttachedAssetControl)
	case "attached_asset_option":
		err = json.Unmarshal(b, &v.AttachedAssetOption)
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	case "custom":
		err = json.Unmarshal(b, &v.Custom)
	case "stat":
		err = json.Unmarshal(b, &v.Stat)
	default:
		err = fmt.Errorf("bad Using value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.Using = t.T
	return nil
}

type ActionRollOptionAssetControl struct {
	Assets []AssetIdwildcard `json:"assets"`

	// The key of the asset control field.
	Control DictKey `json:"control"`
}

type ActionRollOptionAssetOption struct {
	Assets []AssetIdwildcard `json:"assets"`

	// The key of the asset option field.
	Option DictKey `json:"option"`
}

type ActionRollOptionAttachedAssetControl struct {
	// The key of the asset control field.
	Control DictKey `json:"control"`
}

type ActionRollOptionAttachedAssetOption struct {
	// The key of the asset option field.
	Option DictKey `json:"option"`
}

type ActionRollOptionConditionMeter struct {
	ConditionMeter PlayerConditionMeter `json:"condition_meter"`
}

type ActionRollOptionCustom struct {
	Name Label `json:"name"`

	Value int16 `json:"value"`
}

type ActionRollOptionStat struct {
	Stat PlayerStat `json:"stat"`
}

type ActionRollUsing string

const (
	ActionRollUsingAssetControl ActionRollUsing = "asset_control"

	ActionRollUsingAssetOption ActionRollUsing = "asset_option"

	ActionRollUsingAttachedAssetControl ActionRollUsing = "attached_asset_control"

	ActionRollUsingAttachedAssetOption ActionRollUsing = "attached_asset_option"

	ActionRollUsingConditionMeter ActionRollUsing = "condition_meter"

	ActionRollUsingCustom ActionRollUsing = "custom"

	ActionRollUsingStat ActionRollUsing = "stat"
)

type Asset struct {
	Abilities []AssetAbility `json:"abilities"`

	// A localized category label for this asset. This is the surtitle above the
	// asset's name on the card.
	AssetType Label `json:"asset_type"`

	// If `true`, this asset counts as an impact (Starforged) or a debility
	// (classic Ironsworn).
	CountAsImpact bool `json:"count_as_impact"`

	ID AssetID `json:"id"`

	Name Label `json:"name"`

	// Most assets only benefit to their owner, but certain assets (like
	// Starforged's module and command vehicle assets) are shared amongst the
	// player's allies, too.
	Shared bool `json:"shared"`

	Source Source `json:"source"`

	Attachments *AssetAttachment `json:"attachments,omitempty"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	Color *CSSColor `json:"color,omitempty"`

	// Controls are condition meters, clocks, counters, and other asset input
	// fields whose values are expected to change throughout the life of the asset.
	Controls map[string]AssetControlField `json:"controls,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// Options are asset input fields which are set once, usually when the
	// character takes the asset. The most common example is the "name" field on
	// companion assets. A more complex example is the choice of a god's stat for
	// the Devotant asset.
	Options map[string]AssetOptionField `json:"options,omitempty"`

	Requirement *MarkdownString `json:"requirement,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type AssetAbility struct {
	// Is this asset ability enabled?
	Enabled bool `json:"enabled"`

	ID AssetAbilityID `json:"id"`

	Text MarkdownString `json:"text"`

	// Fields whose values are expected to change over the life of the asset.
	Controls map[string]AssetAbilityControlField `json:"controls,omitempty"`

	// Changes made to the asset, when this ability is enabled.
	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	// Describes changes made to various moves by this asset ability. Usually these
	// require specific trigger conditions.
	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`

	// Unique moves added by this asset ability.
	Moves map[string]Move `json:"moves,omitempty"`

	Name *Label `json:"name,omitempty"`

	// Fields that are expected to be set once and remain the same through the life
	// of the asset.
	Options map[string]AssetAbilityOptionField `json:"options,omitempty"`
}

type AssetAbilityControlField struct {
	FieldType string

	Checkbox AssetAbilityControlFieldCheckbox

	Clock AssetAbilityControlFieldClock

	Counter AssetAbilityControlFieldCounter
}

func (v AssetAbilityControlField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "checkbox":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldCheckbox }{ v.FieldType, v.Checkbox })
	case "clock":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldClock }{ v.FieldType, v.Clock })
	case "counter":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldCounter }{ v.FieldType, v.Counter })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetAbilityControlField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "checkbox":
		err = json.Unmarshal(b, &v.Checkbox)
	case "clock":
		err = json.Unmarshal(b, &v.Clock)
	case "counter":
		err = json.Unmarshal(b, &v.Counter)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetAbilityControlFieldCheckbox struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	ID AssetAbilityControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// Is the box checked?
	Value bool `json:"value"`
}

// A clock with 4, 6, 8, or 10 segments.
type AssetAbilityControlFieldClock struct {
	ID AssetAbilityControlFieldID `json:"id"`

	// The size of the clock -- in other words, the maximum number of filled clock
	// segments.
	Max uint8 `json:"max"`

	// The minimum number of filled clock segments. This is always 0.
	Min uint8 `json:"min"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// The current number of filled clock segments.
	Value int16 `json:"value"`
}

// A counter that starts at zero, with an optional maximum value.
type AssetAbilityControlFieldCounter struct {
	ID AssetAbilityControlFieldID `json:"id"`

	Max *int16 `json:"max"`

	// The (inclusive) minimum value.
	Min uint8 `json:"min"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// The current value of this input.
	Value int16 `json:"value"`
}

type AssetAbilityControlFieldID = string

type AssetAbilityID = string

type AssetAbilityOptionField struct {
	FieldType string

	Text AssetAbilityOptionFieldText
}

func (v AssetAbilityOptionField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "text":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityOptionFieldText }{ v.FieldType, v.Text })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetAbilityOptionField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "text":
		err = json.Unmarshal(b, &v.Text)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

// Represents an input that accepts plain text.
type AssetAbilityOptionFieldText struct {
	ID AssetAbilityOptionFieldID `json:"id"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	Value *string `json:"value"`
}

type AssetAbilityOptionFieldID = string

// Describes which assets can be attached to this asset. Example: Starforged's
// Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
// Starforged for more info.
type AssetAttachment struct {
	// Asset IDs (which may be wildcards) that may be attached to this asset
	Assets []AssetIdwildcard `json:"assets"`

	Max *int16 `json:"max"`
}

type AssetConditionMeterControlField struct {
	FieldType string

	CardFlip AssetConditionMeterControlFieldCardFlip

	Checkbox AssetConditionMeterControlFieldCheckbox
}

func (v AssetConditionMeterControlField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "card_flip":
		return json.Marshal(struct { T string `json:"field_type"`; AssetConditionMeterControlFieldCardFlip }{ v.FieldType, v.CardFlip })
	case "checkbox":
		return json.Marshal(struct { T string `json:"field_type"`; AssetConditionMeterControlFieldCheckbox }{ v.FieldType, v.Checkbox })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetConditionMeterControlField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "card_flip":
		err = json.Unmarshal(b, &v.CardFlip)
	case "checkbox":
		err = json.Unmarshal(b, &v.Checkbox)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetConditionMeterControlFieldCardFlip struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	ID AssetConditionMeterControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// Is the card flipped over?
	Value bool `json:"value"`
}

type AssetConditionMeterControlFieldCheckbox struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	ID AssetConditionMeterControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// Is the box checked?
	Value bool `json:"value"`
}

type AssetConditionMeterControlFieldID = string

type AssetControlField struct {
	FieldType string

	CardFlip AssetControlFieldCardFlip

	Checkbox AssetControlFieldCheckbox

	ConditionMeter AssetControlFieldConditionMeter

	SelectEnhancement AssetControlFieldSelectEnhancement
}

func (v AssetControlField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "card_flip":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldCardFlip }{ v.FieldType, v.CardFlip })
	case "checkbox":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldCheckbox }{ v.FieldType, v.Checkbox })
	case "condition_meter":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldConditionMeter }{ v.FieldType, v.ConditionMeter })
	case "select_enhancement":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldSelectEnhancement }{ v.FieldType, v.SelectEnhancement })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetControlField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "card_flip":
		err = json.Unmarshal(b, &v.CardFlip)
	case "checkbox":
		err = json.Unmarshal(b, &v.Checkbox)
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	case "select_enhancement":
		err = json.Unmarshal(b, &v.SelectEnhancement)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetControlFieldCardFlip struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	ID AssetControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// Is the card flipped over?
	Value bool `json:"value"`
}

type AssetControlFieldCheckbox struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	ID AssetControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// Is the box checked?
	Value bool `json:"value"`
}

// Provides hints for moves that interact with this condition meter, such as
// suffer and recovery moves.
type AssetControlFieldConditionMeterMoves struct {
	// The ID(s) of recovery moves associated with this meter.
	Recover []MoveIdwildcard `json:"recover,omitempty"`

	// The ID(s) of suffer moves associated with the condition meter. If the
	// suffer move makes an action roll, this condition meter value should be made
	// available as a roll option.
	Suffer []MoveIdwildcard `json:"suffer,omitempty"`
}

// Some assets provide a special condition meter of their own. The most common
// example is the health meters on companion assets. Asset condition meters
// may also include their own controls, such as the checkboxes that Starforged
// companion assets use to indicate they are "out of action".
type AssetControlFieldConditionMeter struct {
	ID AssetControlFieldID `json:"id"`

	// The maximum value of this meter.
	Max int16 `json:"max"`

	// The minimum value of this meter.
	Min uint8 `json:"min"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// The current value of this meter.
	Value int16 `json:"value"`

	Controls map[string]AssetConditionMeterControlField `json:"controls,omitempty"`

	// Provides hints for moves that interact with this condition meter, such as
	// suffer and recovery moves.
	Moves *AssetControlFieldConditionMeterMoves `json:"moves,omitempty"`
}

type AssetControlFieldSelectEnhancementChoice struct {
	OptionType string

	Option AssetControlFieldSelectEnhancementChoiceOption

	OptionGroup AssetControlFieldSelectEnhancementChoiceOptionGroup
}

func (v AssetControlFieldSelectEnhancementChoice) MarshalJSON() ([]byte, error) {
	switch v.OptionType {
	case "option":
		return json.Marshal(struct { T string `json:"option_type"`; AssetControlFieldSelectEnhancementChoiceOption }{ v.OptionType, v.Option })
	case "option_group":
		return json.Marshal(struct { T string `json:"option_type"`; AssetControlFieldSelectEnhancementChoiceOptionGroup }{ v.OptionType, v.OptionGroup })
	}

	return nil, fmt.Errorf("bad OptionType value: %s", v.OptionType)
}

func (v *AssetControlFieldSelectEnhancementChoice) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"option_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "option":
		err = json.Unmarshal(b, &v.Option)
	case "option_group":
		err = json.Unmarshal(b, &v.OptionGroup)
	default:
		err = fmt.Errorf("bad OptionType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.OptionType = t.T
	return nil
}

// The current value of this input.
type AssetControlFieldSelectEnhancementChoiceOptionValue struct {
	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

// Represents an option in a list of choices.
type AssetControlFieldSelectEnhancementChoiceOption struct {
	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// The current value of this input.
	Value AssetControlFieldSelectEnhancementChoiceOptionValue `json:"value"`

	// Is this option currently selected?
	Selected *bool `json:"selected,omitempty"`
}

type AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType string

const (
	AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionTypeOption AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType = "option"
)

// The current value of this input.
type AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceValue struct {
	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

// Represents an option in a list of choices.
type AssetControlFieldSelectEnhancementChoiceOptionGroupChoice struct {
	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	OptionType AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType `json:"option_type"`

	// The current value of this input.
	Value AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceValue `json:"value"`

	// Is this option currently selected?
	Selected *bool `json:"selected,omitempty"`
}

// Represents a grouping of options in a list of choices.
type AssetControlFieldSelectEnhancementChoiceOptionGroup struct {
	Choices map[string]AssetControlFieldSelectEnhancementChoiceOptionGroupChoice `json:"choices"`

	// A label for this option group.
	Name Label `json:"name"`
}

// Select from player and/or asset enhancements. Use it to describe modal
// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
// (Sundered Isles).
type AssetControlFieldSelectEnhancement struct {
	Choices map[string]AssetControlFieldSelectEnhancementChoice `json:"choices"`

	ID AssetControlFieldID `json:"id"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// The key of the currently selected choice from the `choices` property, or
	// `null` if none is selected.
	Value *DictKey `json:"value"`
}

type AssetControlFieldEnhancement struct {
	FieldType string

	ConditionMeter AssetControlFieldEnhancementConditionMeter
}

func (v AssetControlFieldEnhancement) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "condition_meter":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldEnhancementConditionMeter }{ v.FieldType, v.ConditionMeter })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetControlFieldEnhancement) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

// Some assets provide a special condition meter of their own. The most common
// example is the health meters on companion assets. Asset condition meters
// may also include their own controls, such as the checkboxes that Starforged
// companion assets use to indicate they are "out of action".
type AssetControlFieldEnhancementConditionMeter struct {
	// The maximum value of this meter.
	Max int16 `json:"max"`
}

type AssetControlFieldID = string

type AssetControlFieldIdwildcard = string

// Describes enhancements made to this asset in a partial asset object. The
// changes should be applied recursively; only the values that are specified
// should be changed.
type AssetEnhancement struct {
	Attachments *AssetAttachment `json:"attachments,omitempty"`

	// Controls are condition meters, clocks, counters, and other asset input
	// fields whose values are expected to change throughout the life of the asset.
	Controls map[string]AssetControlFieldEnhancement `json:"controls,omitempty"`

	// If `true`, this asset counts as an impact (Starforged) or a debility
	// (classic Ironsworn).
	CountAsImpact *bool `json:"count_as_impact,omitempty"`

	// Most assets only benefit to their owner, but certain assets (like
	// Starforged's module and command vehicle assets) are shared amongst the
	// player's allies, too.
	Shared *bool `json:"shared,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type AssetID = string

type AssetIdwildcard = string

type AssetOptionField struct {
	FieldType string

	SelectEnhancement AssetOptionFieldSelectEnhancement

	SelectStat AssetOptionFieldSelectStat

	Text AssetOptionFieldText
}

func (v AssetOptionField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "select_enhancement":
		return json.Marshal(struct { T string `json:"field_type"`; AssetOptionFieldSelectEnhancement }{ v.FieldType, v.SelectEnhancement })
	case "select_stat":
		return json.Marshal(struct { T string `json:"field_type"`; AssetOptionFieldSelectStat }{ v.FieldType, v.SelectStat })
	case "text":
		return json.Marshal(struct { T string `json:"field_type"`; AssetOptionFieldText }{ v.FieldType, v.Text })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetOptionField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "select_enhancement":
		err = json.Unmarshal(b, &v.SelectEnhancement)
	case "select_stat":
		err = json.Unmarshal(b, &v.SelectStat)
	case "text":
		err = json.Unmarshal(b, &v.Text)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetOptionFieldSelectEnhancementChoice struct {
	OptionType string

	Option AssetOptionFieldSelectEnhancementChoiceOption

	OptionGroup AssetOptionFieldSelectEnhancementChoiceOptionGroup
}

func (v AssetOptionFieldSelectEnhancementChoice) MarshalJSON() ([]byte, error) {
	switch v.OptionType {
	case "option":
		return json.Marshal(struct { T string `json:"option_type"`; AssetOptionFieldSelectEnhancementChoiceOption }{ v.OptionType, v.Option })
	case "option_group":
		return json.Marshal(struct { T string `json:"option_type"`; AssetOptionFieldSelectEnhancementChoiceOptionGroup }{ v.OptionType, v.OptionGroup })
	}

	return nil, fmt.Errorf("bad OptionType value: %s", v.OptionType)
}

func (v *AssetOptionFieldSelectEnhancementChoice) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"option_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "option":
		err = json.Unmarshal(b, &v.Option)
	case "option_group":
		err = json.Unmarshal(b, &v.OptionGroup)
	default:
		err = fmt.Errorf("bad OptionType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.OptionType = t.T
	return nil
}

// The current value of this input.
type AssetOptionFieldSelectEnhancementChoiceOptionValue struct {
	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

// Represents an option in a list of choices.
type AssetOptionFieldSelectEnhancementChoiceOption struct {
	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// The current value of this input.
	Value AssetOptionFieldSelectEnhancementChoiceOptionValue `json:"value"`

	// Is this option currently selected?
	Selected *bool `json:"selected,omitempty"`
}

type AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType string

const (
	AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionTypeOption AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType = "option"
)

// The current value of this input.
type AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceValue struct {
	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

// Represents an option in a list of choices.
type AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice struct {
	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	OptionType AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType `json:"option_type"`

	// The current value of this input.
	Value AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceValue `json:"value"`

	// Is this option currently selected?
	Selected *bool `json:"selected,omitempty"`
}

// Represents a grouping of options in a list of choices.
type AssetOptionFieldSelectEnhancementChoiceOptionGroup struct {
	Choices map[string]AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice `json:"choices"`

	// A label for this option group.
	Name Label `json:"name"`
}

// Select from player and/or asset enhancements. Use it to describe modal
// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
// (Sundered Isles).
type AssetOptionFieldSelectEnhancement struct {
	Choices map[string]AssetOptionFieldSelectEnhancementChoice `json:"choices"`

	ID AssetOptionFieldID `json:"id"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// The key of the currently selected choice from the `choices` property, or
	// `null` if none is selected.
	Value *DictKey `json:"value"`
}

type AssetOptionFieldSelectStatChoice struct {
	OptionType string

	Option AssetOptionFieldSelectStatChoiceOption

	OptionGroup AssetOptionFieldSelectStatChoiceOptionGroup
}

func (v AssetOptionFieldSelectStatChoice) MarshalJSON() ([]byte, error) {
	switch v.OptionType {
	case "option":
		return json.Marshal(struct { T string `json:"option_type"`; AssetOptionFieldSelectStatChoiceOption }{ v.OptionType, v.Option })
	case "option_group":
		return json.Marshal(struct { T string `json:"option_type"`; AssetOptionFieldSelectStatChoiceOptionGroup }{ v.OptionType, v.OptionGroup })
	}

	return nil, fmt.Errorf("bad OptionType value: %s", v.OptionType)
}

func (v *AssetOptionFieldSelectStatChoice) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"option_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "option":
		err = json.Unmarshal(b, &v.Option)
	case "option_group":
		err = json.Unmarshal(b, &v.OptionGroup)
	default:
		err = fmt.Errorf("bad OptionType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.OptionType = t.T
	return nil
}

// Represents an option in a list of choices.
type AssetOptionFieldSelectStatChoiceOption struct {
	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// The current value of this input.
	Value PlayerStat `json:"value"`

	// Is this option currently selected?
	Selected *bool `json:"selected,omitempty"`
}

type AssetOptionFieldSelectStatChoiceOptionGroupChoiceOptionType string

const (
	AssetOptionFieldSelectStatChoiceOptionGroupChoiceOptionTypeOption AssetOptionFieldSelectStatChoiceOptionGroupChoiceOptionType = "option"
)

// Represents an option in a list of choices.
type AssetOptionFieldSelectStatChoiceOptionGroupChoice struct {
	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	OptionType AssetOptionFieldSelectStatChoiceOptionGroupChoiceOptionType `json:"option_type"`

	// The current value of this input.
	Value PlayerStat `json:"value"`

	// Is this option currently selected?
	Selected *bool `json:"selected,omitempty"`
}

// Represents a grouping of options in a list of choices.
type AssetOptionFieldSelectStatChoiceOptionGroup struct {
	Choices map[string]AssetOptionFieldSelectStatChoiceOptionGroupChoice `json:"choices"`

	// A label for this option group.
	Name Label `json:"name"`
}

// Represents a list of mutually exclusive choices.
type AssetOptionFieldSelectStat struct {
	Choices map[string]AssetOptionFieldSelectStatChoice `json:"choices"`

	ID AssetOptionFieldID `json:"id"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	// The key of the currently selected choice from the `choices` property, or
	// `null` if none is selected.
	Value *DictKey `json:"value"`
}

// Represents an input that accepts plain text.
type AssetOptionFieldText struct {
	ID AssetOptionFieldID `json:"id"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	Value *string `json:"value"`
}

type AssetOptionFieldID = string

type AssetOptionFieldIdwildcard = string

type AssetType struct {
	Contents map[string]Asset `json:"contents"`

	ID AssetTypeID `json:"id"`

	Name Label `json:"name"`

	Source Source `json:"source"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	Color *CSSColor `json:"color,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *AssetTypeID `json:"enhances,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *AssetTypeID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`
}

type AssetTypeID = string

type Atlas struct {
	Collections map[string]Atlas `json:"collections"`

	Contents map[string]AtlasEntry `json:"contents"`

	ID AtlasID `json:"id"`

	Name Label `json:"name"`

	Source Source `json:"source"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	Color *CSSColor `json:"color,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *AtlasID `json:"enhances,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *AtlasID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`
}

// An atlas entry, like the Ironlands region entries found in classic Ironsworn.
type AtlasEntry struct {
	Description MarkdownString `json:"description"`

	Features []MarkdownString `json:"features"`

	ID AtlasEntryID `json:"id"`

	Name Label `json:"name"`

	QuestStarter MarkdownString `json:"quest_starter"`

	Source Source `json:"source"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	YourTruth *MarkdownString `json:"your_truth,omitempty"`
}

type AtlasEntryID = string

type AtlasEntryIdwildcard = string

type AtlasID = string

type AtlasIdwildcard = string

// Challenge rank, represented as an integer:
type ChallengeRank = uint8

type ConditionMeterRule struct {
	Description MarkdownString `json:"description"`

	// The maximum value of this meter.
	Max int16 `json:"max"`

	// The minimum value of this meter.
	Min int16 `json:"min"`

	// A label for this input. In some contexts it may be undesirable to render
	// this text, but it should always be exposed to assistive technology (e.g.
	// with `aria-label` in HTML).
	Name Label `json:"name"`

	Shared bool `json:"shared"`
}

type ConditionMeterRuleID = string

// A CSS color value. See: https://developer.mozilla.org/en-
// US/docs/Web/CSS/color_value
type CSSColor = string

// A delve site with a theme, domain, and denizen table.
type DelveSite struct {
	Denizens []DelveSiteDenizen `json:"denizens"`

	Description MarkdownString `json:"description"`

	Domain DelveSiteDomainID `json:"domain"`

	ID DelveSiteID `json:"id"`

	Name Label `json:"name"`

	Rank ChallengeRank `json:"rank"`

	Source Source `json:"source"`

	Theme DelveSiteThemeID `json:"theme"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	// An additional theme or domain card ID, for use with optional rules in
	// Ironsworn: Delve.
	ExtraCard *string `json:"extra_card,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// The ID of an atlas entry representing the region in which this delve site
	// is located.
	Region *AtlasEntryID `json:"region,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type DelveSiteDenizen struct {
	Frequency DelveSiteDenizenFrequency `json:"frequency"`

	ID DelveSiteDenizenID `json:"id"`

	Max int16 `json:"max"`

	Min int16 `json:"min"`

	Name *Label `json:"name,omitempty"`

	// The ID of the relevant NPC entry, if one is specified.
	Npc *NpcID `json:"npc,omitempty"`
}

type DelveSiteDenizenFrequency string

const (
	DelveSiteDenizenFrequencyCommon DelveSiteDenizenFrequency = "common"

	DelveSiteDenizenFrequencyRare DelveSiteDenizenFrequency = "rare"

	DelveSiteDenizenFrequencyUncommon DelveSiteDenizenFrequency = "uncommon"

	DelveSiteDenizenFrequencyUnforeseen DelveSiteDenizenFrequency = "unforeseen"

	DelveSiteDenizenFrequencyVeryCommon DelveSiteDenizenFrequency = "very_common"
)

type DelveSiteDenizenID = string

type DelveSiteDomainCardType string

const (
	DelveSiteDomainCardTypeDomain DelveSiteDomainCardType = "domain"
)

type DelveSiteDomain struct {
	CardType DelveSiteDomainCardType `json:"card_type"`

	Dangers []DelveSiteDomainDangerRow `json:"dangers"`

	Features []DelveSiteDomainFeatureRow `json:"features"`

	ID DelveSiteDomainID `json:"id"`

	Name Label `json:"name"`

	Source Source `json:"source"`

	Summary MarkdownString `json:"summary"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// An oracle table ID containing place name elements. For examples, see
	// oracle ID `delve/oracles/site_name/place/barrow`, and its siblings in
	// oracle collection ID `delve/collections/oracles/site_name/place`. These
	// oracles are used by the site name oracle from Ironsworn: Delve (ID:
	// delve/oracles/site_name/format) to create random names for delve sites.
	NameOracle *OracleTableID `json:"name_oracle,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type DelveSiteDomainDangerRow struct {
	ID DomainDangerRowID `json:"id"`

	// High end of the dice range for this table row. `null` represents an
	// unrollable row, included only for rendering purposes.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row. `null` represents an
	// unrollable row, included only for rendering purposes.
	Min int16 `json:"min"`

	Result MarkdownString `json:"result"`

	Description *MarkdownString `json:"description,omitempty"`

	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

type DelveSiteDomainFeatureRow struct {
	ID DomainFeatureRowID `json:"id"`

	// High end of the dice range for this table row. `null` represents an
	// unrollable row, included only for rendering purposes.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row. `null` represents an
	// unrollable row, included only for rendering purposes.
	Min int16 `json:"min"`

	Result MarkdownString `json:"result"`

	Description *MarkdownString `json:"description,omitempty"`

	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

type DelveSiteDomainID = string

type DelveSiteID = string

type DelveSiteThemeCardType string

const (
	DelveSiteThemeCardTypeTheme DelveSiteThemeCardType = "theme"
)

type DelveSiteTheme struct {
	CardType DelveSiteThemeCardType `json:"card_type"`

	Dangers []DelveSiteThemeDangerRow `json:"dangers"`

	Features []DelveSiteThemeFeatureRow `json:"features"`

	ID DelveSiteThemeID `json:"id"`

	Name Label `json:"name"`

	Source Source `json:"source"`

	Summary MarkdownString `json:"summary"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type DelveSiteThemeDangerRow struct {
	ID ThemeDangerRowID `json:"id"`

	// High end of the dice range for this table row. `null` represents an
	// unrollable row, included only for rendering purposes.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row. `null` represents an
	// unrollable row, included only for rendering purposes.
	Min int16 `json:"min"`

	Result MarkdownString `json:"result"`

	Description *MarkdownString `json:"description,omitempty"`

	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

type DelveSiteThemeFeatureRow struct {
	ID ThemeFeatureRowID `json:"id"`

	// High end of the dice range for this table row. `null` represents an
	// unrollable row, included only for rendering purposes.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row. `null` represents an
	// unrollable row, included only for rendering purposes.
	Min int16 `json:"min"`

	Result MarkdownString `json:"result"`

	Description *MarkdownString `json:"description,omitempty"`

	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

type DelveSiteThemeID = string

type DiceNotation = string

// A key used in a Datasworn dictionary object.
type DictKey = string

type DomainDangerRowID = string

type DomainFeatureRowID = string

type I18nHint struct {
	PartOfSpeech *PartOfSpeech `json:"part_of_speech,omitempty"`
}

type I18nHintsTemplate struct {
	Description *I18nHint `json:"description,omitempty"`

	Result *I18nHint `json:"result,omitempty"`

	Summary *I18nHint `json:"summary,omitempty"`
}

type I18nHints struct {
	Description *I18nHint `json:"description,omitempty"`

	Result *I18nHint `json:"result,omitempty"`

	Summary *I18nHint `json:"summary,omitempty"`

	Template *I18nHintsTemplate `json:"template,omitempty"`
}

type ImpactCategory struct {
	Contents map[string]ImpactRule `json:"contents"`

	Description MarkdownString `json:"description"`

	Name Label `json:"name"`
}

type ImpactRule struct {
	Description MarkdownString `json:"description"`

	Name Label `json:"name"`

	Permanent bool `json:"permanent"`

	PreventsRecovery []DictKey `json:"prevents_recovery"`

	Shared bool `json:"shared"`
}

type ImpactRuleCollectionID = string

type ImpactRuleID = string

// A localized plain text name or label.
type Label = string

// Localized text, formatted in Markdown.
// 
// It uses some custom syntax; e.g. `{{table:some_oracle_table_id}}` indicates
// that the referenced oracle table is rendered there part of the source
// material.
type MarkdownString = string

type Move struct {
	RollType string

	ActionRoll MoveActionRoll

	NoRoll MoveNoRoll

	ProgressRoll MoveProgressRoll

	SpecialTrack MoveSpecialTrack
}

func (v Move) MarshalJSON() ([]byte, error) {
	switch v.RollType {
	case "action_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveActionRoll }{ v.RollType, v.ActionRoll })
	case "no_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveNoRoll }{ v.RollType, v.NoRoll })
	case "progress_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveProgressRoll }{ v.RollType, v.ProgressRoll })
	case "special_track":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveSpecialTrack }{ v.RollType, v.SpecialTrack })
	}

	return nil, fmt.Errorf("bad RollType value: %s", v.RollType)
}

func (v *Move) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"roll_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "action_roll":
		err = json.Unmarshal(b, &v.ActionRoll)
	case "no_roll":
		err = json.Unmarshal(b, &v.NoRoll)
	case "progress_roll":
		err = json.Unmarshal(b, &v.ProgressRoll)
	case "special_track":
		err = json.Unmarshal(b, &v.SpecialTrack)
	default:
		err = fmt.Errorf("bad RollType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.RollType = t.T
	return nil
}

// A move that makes an action roll.
type MoveActionRoll struct {
	ID MoveID `json:"id"`

	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	Source Source `json:"source"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	Trigger TriggerActionRoll `json:"trigger"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	// Oracles associated with this move. It's not recommended to roll these
	// automatically, as almost all moves present them as an option, not a
	// requirement.
	Oracles []OracleTableID `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified move. References to the
	// replaced move can be considered equivalent to this move.
	Replaces *MoveID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type MoveNoRoll struct {
	ID MoveID `json:"id"`

	Name Label `json:"name"`

	Outcomes interface{} `json:"outcomes"`

	Source Source `json:"source"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	Trigger TriggerNoRoll `json:"trigger"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	// Oracles associated with this move. It's not recommended to roll these
	// automatically, as almost all moves present them as an option, not a
	// requirement.
	Oracles []OracleTableID `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified move. References to the
	// replaced move can be considered equivalent to this move.
	Replaces *MoveID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

// A progress move that rolls on a standard progress track type (defined by the
// move object).
type MoveProgressRoll struct {
	ID MoveID `json:"id"`

	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	Source Source `json:"source"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// A category label for progress tracks associated with this move.
	TrackLabel Label `json:"track_label"`

	Trigger TriggerProgressRoll `json:"trigger"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	// Oracles associated with this move. It's not recommended to roll these
	// automatically, as almost all moves present them as an option, not a
	// requirement.
	Oracles []OracleTableID `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified move. References to the
	// replaced move can be considered equivalent to this move.
	Replaces *MoveID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type MoveSpecialTrack struct {
	ID MoveID `json:"id"`

	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	Source Source `json:"source"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	Trigger TriggerSpecialTrack `json:"trigger"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	// Oracles associated with this move. It's not recommended to roll these
	// automatically, as almost all moves present them as an option, not a
	// requirement.
	Oracles []OracleTableID `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified move. References to the
	// replaced move can be considered equivalent to this move.
	Replaces *MoveID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type MoveCategory struct {
	Contents map[string]Move `json:"contents"`

	ID MoveCategoryID `json:"id"`

	Name Label `json:"name"`

	Source Source `json:"source"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	Color *CSSColor `json:"color,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *MoveCategoryID `json:"enhances,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *MoveCategoryID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`
}

type MoveCategoryID = string

type MoveEnhancement struct {
	RollType string

	ActionRoll MoveEnhancementActionRoll

	NoRoll MoveEnhancementNoRoll

	ProgressRoll MoveEnhancementProgressRoll

	SpecialTrack MoveEnhancementSpecialTrack
}

func (v MoveEnhancement) MarshalJSON() ([]byte, error) {
	switch v.RollType {
	case "action_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementActionRoll }{ v.RollType, v.ActionRoll })
	case "no_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementNoRoll }{ v.RollType, v.NoRoll })
	case "progress_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementProgressRoll }{ v.RollType, v.ProgressRoll })
	case "special_track":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementSpecialTrack }{ v.RollType, v.SpecialTrack })
	}

	return nil, fmt.Errorf("bad RollType value: %s", v.RollType)
}

func (v *MoveEnhancement) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"roll_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "action_roll":
		err = json.Unmarshal(b, &v.ActionRoll)
	case "no_roll":
		err = json.Unmarshal(b, &v.NoRoll)
	case "progress_roll":
		err = json.Unmarshal(b, &v.ProgressRoll)
	case "special_track":
		err = json.Unmarshal(b, &v.SpecialTrack)
	default:
		err = fmt.Errorf("bad RollType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.RollType = t.T
	return nil
}

type MoveEnhancementActionRoll struct {
	Enhances []MoveIdwildcard `json:"enhances,omitempty"`

	Trigger *TriggerActionRollEnhancement `json:"trigger,omitempty"`
}

type MoveEnhancementNoRoll struct {
	Enhances []MoveIdwildcard `json:"enhances,omitempty"`

	Trigger *TriggerNoRollEnhancement `json:"trigger,omitempty"`
}

type MoveEnhancementProgressRoll struct {
	Enhances []MoveIdwildcard `json:"enhances,omitempty"`

	Trigger *TriggerProgressRollEnhancement `json:"trigger,omitempty"`
}

type MoveEnhancementSpecialTrack struct {
	Enhances []MoveIdwildcard `json:"enhances,omitempty"`

	Trigger *TriggerSpecialTrackEnhancement `json:"trigger,omitempty"`
}

// A move ID, for a standard move or a unique asset move
type MoveID = string

// A move ID with wildcards
type MoveIdwildcard = string

type MoveOutcome struct {
	Text MarkdownString `json:"text"`
}

type MoveOutcomeType string

const (
	MoveOutcomeTypeMiss MoveOutcomeType = "miss"

	MoveOutcomeTypeStrongHit MoveOutcomeType = "strong_hit"

	MoveOutcomeTypeWeakHit MoveOutcomeType = "weak_hit"
)

// A standalone localized description for each move outcome (miss, weak hit,
// or strong hit). This is for for e.g. VTT implementations, where it's often
// useful to display only the rules text relevant to a roll result.
// 
//   This often requires light editorialization to create text that can stand
// alone without reference to the rest of the move. For example, 'as above'
// (in reference to another move outcome) shouldn't be used here; instead, the
// relevant text should be repeated.
type MoveOutcomes struct {
	Miss MoveOutcome `json:"miss"`

	StrongHit MoveOutcome `json:"strong_hit"`

	WeakHit MoveOutcome `json:"weak_hit"`
}

type MoveRollType string

const (
	MoveRollTypeActionRoll MoveRollType = "action_roll"

	MoveRollTypeNoRoll MoveRollType = "no_roll"

	MoveRollTypeProgressRoll MoveRollType = "progress_roll"

	MoveRollTypeSpecialTrack MoveRollType = "special_track"
)

type NamespaceID = string

// A non-player character entry, similar to those in Chapter 5 of the Ironsworn
// Rulebook, or Chapter 4 of Starforged.
type Npc struct {
	Description MarkdownString `json:"description"`

	Drives []MarkdownString `json:"drives"`

	Features []MarkdownString `json:"features"`

	ID NpcID `json:"id"`

	Name Label `json:"name"`

	Nature NpcNature `json:"nature"`

	QuestStarter MarkdownString `json:"quest_starter"`

	Rank ChallengeRank `json:"rank"`

	Source Source `json:"source"`

	Tactics []MarkdownString `json:"tactics"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Variants map[string]NpcVariant `json:"variants,omitempty"`

	YourTruth *MarkdownString `json:"your_truth,omitempty"`
}

type NpcCollection struct {
	Contents map[string]Npc `json:"contents"`

	ID NpcCollectionID `json:"id"`

	Name Label `json:"name"`

	Source Source `json:"source"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	Color *CSSColor `json:"color,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *NpcCollectionID `json:"enhances,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *NpcCollectionID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`
}

type NpcCollectionID = string

type NpcID = string

type NpcIdwildcard = string

// A localized category label describing the nature of this NPC.
// 
// In Ironsworn classic, this is probably the singular form of the parent
// collection's name.
// 
// For Starforged, see the table on p. 258 for examples.
type NpcNature = Label

type NpcVariant struct {
	Description MarkdownString `json:"description"`

	ID NpcVariantID `json:"id"`

	Name Label `json:"name"`

	Nature NpcNature `json:"nature"`

	Rank ChallengeRank `json:"rank"`

	Summary *MarkdownString `json:"summary,omitempty"`
}

type NpcVariantID = string

type OracleCollection struct {
	Collections map[string]OracleCollection `json:"collections"`

	Contents map[string]OracleTable `json:"contents"`

	ID OracleCollectionID `json:"id"`

	Name Label `json:"name"`

	Source Source `json:"source"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	Color *CSSColor `json:"color,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *OracleCollectionID `json:"enhances,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Rendering *OracleCollectionRendering `json:"rendering,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *OracleCollectionID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`
}

type OracleCollectionID = string

type OracleCollectionRendering struct {
	Columns map[string]OracleCollectionTableColumn `json:"columns"`

	Color *CSSColor `json:"color,omitempty"`

	TableStyle *OracleCollectionStyle `json:"table_style,omitempty"`
}

type OracleCollectionStyle string

const (
	OracleCollectionStyleCollection OracleCollectionStyle = "collection"

	OracleCollectionStyleMultiTable OracleCollectionStyle = "multi_table"
)

type OracleCollectionTableColumn struct {
	ContentType OracleTableColumnContentKey `json:"content_type"`

	// The key of the OracleTable (within this collection), whose data is used to
	// render this column.
	TableKey DictKey `json:"table_key"`

	// The thematic color for this column.
	Color *CSSColor `json:"color,omitempty"`

	// The column's header text.
	Name *Label `json:"name,omitempty"`
}

// Provides string templates that may be used in place of the static
// row text from `OracleTableRow#result`, `OracleTableRow#summary`, and
// `OracleTableRow#description`.
// 
//   These strings are formatted in Markdown, but use a special syntax for their
// placeholders: `{{result:some_oracle_table_id}}`. The placeholder should be
// replaced with the value of a rolled (or selected) `OracleTableRow#result`
// from the target oracle table ID.
type OracleRollTemplate struct {
	// A string template that may be used in place of OracleTableRow#description.
	Description *TemplateString `json:"description,omitempty"`

	// A string template that may be used in place of OracleTableRow#result.
	Result *TemplateString `json:"result,omitempty"`

	// A string template that may be used in place of OracleTableRow#summary.
	Summary *TemplateString `json:"summary,omitempty"`
}

type OracleTable struct {
	Dice DiceNotation `json:"dice"`

	ID OracleTableID `json:"id"`

	Name Label `json:"name"`

	Source Source `json:"source"`

	Table []OracleTableRow `json:"table"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A longer description of the oracle table's intended usage, which might
	// include multiple paragraphs. If it's only a couple sentences, use the
	// `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Match *OracleTableMatchBehavior `json:"match,omitempty"`

	Rendering *OracleTableRendering `json:"rendering,omitempty"`

	// Indicates that this table replaces the identified table. References to the
	// replaced table can be considered equivalent to this table.
	Replaces *OracleTableID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of the oracle table's intended usage, no more than a few
	// sentences in length. This is intended for use in application tooltips
	// and similar sorts of hints. Longer text should use the "description" key
	// instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

type OracleTableColumn struct {
	ContentType OracleTableColumnContentKey `json:"content_type"`

	// The thematic color for this column.
	Color *CSSColor `json:"color,omitempty"`

	// The column's header text.
	Name *Label `json:"name,omitempty"`
}

// The value(s) from each OracleTableRow that is rendered in this column.
type OracleTableColumnContentKey string

const (
	OracleTableColumnContentKeyDescription OracleTableColumnContentKey = "description"

	OracleTableColumnContentKeyResult OracleTableColumnContentKey = "result"

	OracleTableColumnContentKeyRoll OracleTableColumnContentKey = "roll"

	OracleTableColumnContentKeySummary OracleTableColumnContentKey = "summary"
)

type OracleTableID = string

// Oracle table wildcards can also use '**' to represent any
// number of collection levels in the oracle tree. For example,
// 'starforged/oracles/**/location' represents any starforged table with the
// "location" key.
type OracleTableIdwildcard = string

type OracleTableMatchBehavior struct {
	Text MarkdownString `json:"text"`
}

type OracleTableRendering struct {
	Columns map[string]OracleTableColumn `json:"columns"`

	TableStyle *OracleTableStyle `json:"table_style,omitempty"`
}

type OracleTableRoll struct {
	// The rulebook explicitly cautions *against* rolling all details at once,
	// so rolling every referenced oracle automatically is not recommended. That
	// said, some oracle results only provide useful information once a secondary
	// roll occurs, such as "Action + Theme". If this value is omitted, assume
	// it's false.
	Auto *bool `json:"auto,omitempty"`

	Method *OracleTableRollMethod `json:"method,omitempty"`

	// The ID of the oracle table to be rolled. If omitted, it defaults to the ID
	// of this oracle table.
	Oracle *OracleTableID `json:"oracle,omitempty"`

	Times *int16 `json:"times,omitempty"`
}

// Special roll instructions to use when rolling multiple times on a single
// oracle table.
type OracleTableRollMethod string

const (
	OracleTableRollMethodKeepDuplicates OracleTableRollMethod = "keep_duplicates"

	OracleTableRollMethodMakeItWorse OracleTableRollMethod = "make_it_worse"

	OracleTableRollMethodNoDuplicates OracleTableRollMethod = "no_duplicates"
)

type OracleTableRow struct {
	ID OracleTableRowID `json:"id"`

	Max *int16 `json:"max"`

	Min *int16 `json:"min"`

	Result MarkdownString `json:"result"`

	Description *MarkdownString `json:"description,omitempty"`

	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// Normally, rows will end with two numbers separated by a dash, indicating
// their dice range.
// 
// Rows with a single number represent unrollable rows that are sometimes
// included for rendering purposes; in this case, the number represents the
// row's index.
type OracleTableRowID = string

type OracleTableStyle string

const (
	OracleTableStyleEmbedAsColumn OracleTableStyle = "embed_as_column"

	OracleTableStyleEmbedInRow OracleTableStyle = "embed_in_row"

	OracleTableStyleStandaloneTable OracleTableStyle = "standalone_table"
)

type PartOfSpeech string

const (
	PartOfSpeechAdjective PartOfSpeech = "adjective"

	PartOfSpeechAdjunctCommonNoun PartOfSpeech = "adjunct_common_noun"

	PartOfSpeechAdjunctProperNoun PartOfSpeech = "adjunct_proper_noun"

	PartOfSpeechAttributiveVerb PartOfSpeech = "attributive_verb"

	PartOfSpeechCommonNoun PartOfSpeech = "common_noun"

	PartOfSpeechGerund PartOfSpeech = "gerund"

	PartOfSpeechProperNoun PartOfSpeech = "proper_noun"

	PartOfSpeechVerb PartOfSpeech = "verb"
)

// A basic, rollable player character resource.
type PlayerConditionMeter = DictKey

// A basic player character stat.
type PlayerStat = DictKey

type ProgressRollMethod string

const (
	ProgressRollMethodMiss ProgressRollMethod = "miss"

	ProgressRollMethodProgressRoll ProgressRollMethod = "progress_roll"

	ProgressRollMethodStrongHit ProgressRollMethod = "strong_hit"

	ProgressRollMethodWeakHit ProgressRollMethod = "weak_hit"
)

type ProgressRollOptionUsing string

const (
	ProgressRollOptionUsingProgressTrack ProgressRollOptionUsing = "progress_track"
)

type ProgressRollOption struct {
	Using ProgressRollOptionUsing `json:"using"`
}

// A rarity, as described in Ironsworn: Delve.
type Rarity struct {
	// The asset augmented by this rarity.
	Asset AssetID `json:"asset"`

	Description MarkdownString `json:"description"`

	ID RarityID `json:"id"`

	Name Label `json:"name"`

	Source Source `json:"source"`

	// From Ironsworn: Delve, p. 174:
	// 
	//       Some assets will bring a rarity into play more often than others, so
	// the experience point cost for a rarity will vary by the linked asset. These
	// costs are shown in the tables on page 175.
	// 
	//       If you are playing solo, and arent concerned with the relative
	// balance of rarity abilities, you can ignore these variable costs. If so,
	// spend 3 experience points to purchase a rarity.
	XpCost int16 `json:"xp_cost"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type RarityID = string

type Rules struct {
	ConditionMeters map[string]ConditionMeterRule `json:"condition_meters"`

	Impacts map[string]ImpactCategory `json:"impacts"`

	SpecialTracks map[string]SpecialTrackRule `json:"special_tracks"`

	Stats map[string]StatRule `json:"stats"`
}

type SourceAuthor struct {
	Name string `json:"name"`

	// An optional email contact for the author
	Email *string `json:"email,omitempty"`

	// An optional URL for the author's website.
	URL *string `json:"url,omitempty"`
}

// Metadata describing the original source of this item
type Source struct {
	Authors []SourceAuthor `json:"authors"`

	// The date of the source documents's last update, formatted YYYY-MM-DD.
	// Required because it's used to determine whether the data needs updating.
	Date string `json:"date"`

	License *string `json:"license"`

	// The title of the source document.
	Title string `json:"title"`

	// An absolute URL where the source document is available.
	URL string `json:"url"`

	// The page number where this item is described in full.
	Page *int16 `json:"page,omitempty"`
}

type SpecialTrackRollMethod string

const (
	SpecialTrackRollMethodAll SpecialTrackRollMethod = "all"

	SpecialTrackRollMethodHighest SpecialTrackRollMethod = "highest"

	SpecialTrackRollMethodLowest SpecialTrackRollMethod = "lowest"

	SpecialTrackRollMethodMiss SpecialTrackRollMethod = "miss"

	SpecialTrackRollMethodPlayerChoice SpecialTrackRollMethod = "player_choice"

	SpecialTrackRollMethodStrongHit SpecialTrackRollMethod = "strong_hit"

	SpecialTrackRollMethodWeakHit SpecialTrackRollMethod = "weak_hit"
)

type SpecialTrackRule struct {
	Description MarkdownString `json:"description"`

	Name Label `json:"name"`

	Optional bool `json:"optional"`

	Shared bool `json:"shared"`
}

type SpecialTrackRuleID = string

// Special, ruleset-specific progress tracks. Usually, one exists per player
// character, and they persist through the life of the player character.
// 'Canonical' examples:
//   * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
// legacy track, use `bonds_legacy` instead.
//   * `failure_track`, described in Ironsworn: Delve
//   * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
// Ironsworn: Starforged
// 
type SpecialTrackType = DictKey

type StatRule struct {
	Description MarkdownString `json:"description"`

	Name Label `json:"name"`
}

type StatRuleID = string

type Suggestions struct {
	Assets []AssetID `json:"assets,omitempty"`

	Atlas []AtlasEntryID `json:"atlas,omitempty"`

	Moves []MoveID `json:"moves,omitempty"`

	Npcs []NpcID `json:"npcs,omitempty"`

	Oracles []OracleTableID `json:"oracles,omitempty"`

	SiteDomains []DelveSiteDomainID `json:"site_domains,omitempty"`

	SiteThemes []DelveSiteThemeID `json:"site_themes,omitempty"`
}

// A relative URL pointing to a vector image in the SVG format.
type SvgImageURL = string

// A rich text string in Markdown with replaced values from oracle roll results.
// 
// The custom syntax `{{some_row_key:some_oracle_table_id}}` should be replaced
// by the `some_row_key` string of a rolled oracle table. This is usually the
// `result` key, for example `{{result:starforged/oracles/core/action}}`
type TemplateString = string

type ThemeDangerRowID = string

type ThemeFeatureRowID = string

type TriggerActionRoll struct {
	Conditions []TriggerActionRollCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerActionRollCondition struct {
	Method ActionRollMethod `json:"method"`

	// The options available when rolling with this trigger.
	RollOptions []ActionRollOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerActionRollConditionEnhancement struct {
	Method *ActionRollMethod `json:"method"`

	// The options available when rolling with this trigger.
	RollOptions []ActionRollOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerActionRollEnhancement struct {
	Conditions []TriggerActionRollConditionEnhancement `json:"conditions"`
}

// Information on who can trigger this trigger condition. Usually this is just
// the player, but some asset abilities can trigger from an ally's move.
type TriggerBy struct {
	Ally bool `json:"ally"`

	Player bool `json:"player"`
}

type TriggerNoRoll struct {
	Conditions []TriggerNoRollCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerNoRollCondition struct {
	Method interface{} `json:"method"`

	// The options available when rolling with this trigger.
	RollOptions interface{} `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerNoRollEnhancement struct {
	Conditions []TriggerNoRollCondition `json:"conditions"`
}

type TriggerProgressRoll struct {
	Conditions []TriggerProgressRollCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerProgressRollCondition struct {
	Method ProgressRollMethod `json:"method"`

	// The options available when rolling with this trigger.
	RollOptions []ProgressRollOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerProgressRollConditionEnhancement struct {
	Method *ProgressRollMethod `json:"method"`

	// The options available when rolling with this trigger.
	RollOptions []ProgressRollOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerProgressRollEnhancement struct {
	Conditions []TriggerProgressRollConditionEnhancement `json:"conditions"`
}

type TriggerSpecialTrack struct {
	Conditions []TriggerSpecialTrackCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerSpecialTrackCondition struct {
	Method SpecialTrackRollMethod `json:"method"`

	// The options available when rolling with this trigger.
	RollOptions []TriggerSpecialTrackConditionOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

// A progress move that rolls on one or more special tracks, like Bonds (classic
// Ironsworn), Failure (Delve), or Legacy (Starforged).
type TriggerSpecialTrackConditionEnhancement struct {
	Method *SpecialTrackRollMethod `json:"method"`

	// The options available when rolling with this trigger.
	RollOptions []TriggerSpecialTrackConditionOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerSpecialTrackConditionOption struct {
	Using SpecialTrackType `json:"using"`
}

type TriggerSpecialTrackEnhancement struct {
	Conditions []TriggerSpecialTrackConditionEnhancement `json:"conditions"`
}

// A setting truth category.
type Truth struct {
	ID TruthID `json:"id"`

	Name Label `json:"name"`

	Options []TruthOption `json:"options"`

	Source Source `json:"source"`

	CanonicalName *Label `json:"canonical_name,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	YourCharacter *MarkdownString `json:"your_character,omitempty"`
}

type TruthID = string

type TruthOption struct {
	Description MarkdownString `json:"description"`

	ID TruthOptionID `json:"id"`

	QuestStarter MarkdownString `json:"quest_starter"`

	Max *int16 `json:"max,omitempty"`

	Min *int16 `json:"min,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Table []TruthOptionTableRow `json:"table,omitempty"`
}

type TruthOptionID = string

type TruthOptionTableRow struct {
	Max *int16 `json:"max"`

	Min *int16 `json:"min"`

	Result MarkdownString `json:"result"`

	Description *MarkdownString `json:"description,omitempty"`

	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// A relative URL pointing to a raster image in the WEBP format.
type WebpImageURL = string
